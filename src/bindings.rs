/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201605;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 24;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __ENUM_IDTYPE_T: ::std::os::raw::c_uint = 1;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const TRUE: ::std::os::raw::c_uint = 1;
pub const TPM_Vendor_Specific32: ::std::os::raw::c_uint = 1024;
pub const TPM_Vendor_Specific8: ::std::os::raw::c_uint = 128;
pub const TPM_SHA1_160_HASH_LEN: ::std::os::raw::c_uint = 20;
pub const TPM_SHA1BASED_NONCE_LEN: ::std::os::raw::c_uint = 20;
pub const TPM_FAMILY_TABLE_ENTRY_MIN: ::std::os::raw::c_uint = 8;
pub const TPM_NUM_DELEGATE_TABLE_ENTRY_MIN: ::std::os::raw::c_uint = 2;
pub const TPM_DA_STATE_INACTIVE: ::std::os::raw::c_uint = 0;
pub const TPM_DA_STATE_ACTIVE: ::std::os::raw::c_uint = 1;
pub const TPM_DAA_SIZE_r0: ::std::os::raw::c_uint = 43;
pub const TPM_DAA_SIZE_r1: ::std::os::raw::c_uint = 43;
pub const TPM_DAA_SIZE_r2: ::std::os::raw::c_uint = 128;
pub const TPM_DAA_SIZE_r3: ::std::os::raw::c_uint = 168;
pub const TPM_DAA_SIZE_r4: ::std::os::raw::c_uint = 219;
pub const TPM_DAA_SIZE_NT: ::std::os::raw::c_uint = 20;
pub const TPM_DAA_SIZE_v0: ::std::os::raw::c_uint = 128;
pub const TPM_DAA_SIZE_v1: ::std::os::raw::c_uint = 192;
pub const TPM_DAA_SIZE_NE: ::std::os::raw::c_uint = 256;
pub const TPM_DAA_SIZE_w: ::std::os::raw::c_uint = 256;
pub const TPM_DAA_SIZE_issuerModulus: ::std::os::raw::c_uint = 256;
pub const TPM_DAA_power0: ::std::os::raw::c_uint = 104;
pub const TPM_DAA_power1: ::std::os::raw::c_uint = 1024;
pub const TPM_REDIR_GPIO: ::std::os::raw::c_uint = 1;
pub const TPM_SYM_MODE_ECB: ::std::os::raw::c_uint = 1;
pub const TPM_SYM_MODE_CBC: ::std::os::raw::c_uint = 2;
pub const TPM_SYM_MODE_CFB: ::std::os::raw::c_uint = 3;
pub const TCPA_Vendor_Specific32: ::std::os::raw::c_uint = 1024;
pub const TCPA_Vendor_Specific8: ::std::os::raw::c_uint = 128;
pub const TCPA_SHA1_160_HASH_LEN: ::std::os::raw::c_uint = 20;
pub const TCPA_SHA1BASED_NONCE_LEN: ::std::os::raw::c_uint = 20;
pub const TSS_LAYER_TPM: ::std::os::raw::c_uint = 0;
pub const TSS_LAYER_TDDL: ::std::os::raw::c_uint = 4096;
pub const TSS_LAYER_TCS: ::std::os::raw::c_uint = 8192;
pub const TSS_LAYER_TSP: ::std::os::raw::c_uint = 12288;
pub const TSS_COMMON_OFFSET: ::std::os::raw::c_uint = 0;
pub const TSS_TDDL_OFFSET: ::std::os::raw::c_uint = 128;
pub const TSS_TCSI_OFFSET: ::std::os::raw::c_uint = 192;
pub const TSS_TSPI_OFFSET: ::std::os::raw::c_uint = 256;
pub const TSS_VENDOR_OFFSET: ::std::os::raw::c_uint = 2048;
pub const TSS_MAX_ERROR: ::std::os::raw::c_uint = 4095;
pub const TSS_LEVEL_SUCCESS: ::std::os::raw::c_uint = 0;
pub const TSS_LEVEL_INFO: ::std::os::raw::c_uint = 1073741824;
pub const TSS_LEVEL_WARNING: ::std::os::raw::c_uint = 2147483648;
pub const TSS_LEVEL_ERROR: ::std::os::raw::c_uint = 3221225472;
pub const FACILITY_TSS: ::std::os::raw::c_uint = 40;
pub const FACILITY_TSS_CODEPOS: ::std::os::raw::c_uint = 2621440;
pub const TSS_CUSTOM_CODEFLAG: ::std::os::raw::c_uint = 536870912;
pub const TSS_E_BASE: ::std::os::raw::c_uint = 0;
pub const TSS_W_BASE: ::std::os::raw::c_uint = 0;
pub const TSS_I_BASE: ::std::os::raw::c_uint = 0;
pub const TSS_OBJECT_TYPE_POLICY: ::std::os::raw::c_uint = 1;
pub const TSS_OBJECT_TYPE_RSAKEY: ::std::os::raw::c_uint = 2;
pub const TSS_OBJECT_TYPE_ENCDATA: ::std::os::raw::c_uint = 3;
pub const TSS_OBJECT_TYPE_PCRS: ::std::os::raw::c_uint = 4;
pub const TSS_OBJECT_TYPE_HASH: ::std::os::raw::c_uint = 5;
pub const TSS_OBJECT_TYPE_DELFAMILY: ::std::os::raw::c_uint = 6;
pub const TSS_OBJECT_TYPE_NV: ::std::os::raw::c_uint = 7;
pub const TSS_OBJECT_TYPE_MIGDATA: ::std::os::raw::c_uint = 8;
pub const TSS_OBJECT_TYPE_DAA_CERTIFICATE: ::std::os::raw::c_uint = 9;
pub const TSS_OBJECT_TYPE_DAA_ISSUER_KEY: ::std::os::raw::c_uint = 10;
pub const TSS_OBJECT_TYPE_DAA_ARA_KEY: ::std::os::raw::c_uint = 11;
pub const TSS_KEY_NO_AUTHORIZATION: ::std::os::raw::c_uint = 0;
pub const TSS_KEY_AUTHORIZATION: ::std::os::raw::c_uint = 1;
pub const TSS_KEY_AUTHORIZATION_PRIV_USE_ONLY: ::std::os::raw::c_uint = 2;
pub const TSS_KEY_NON_VOLATILE: ::std::os::raw::c_uint = 0;
pub const TSS_KEY_VOLATILE: ::std::os::raw::c_uint = 4;
pub const TSS_KEY_NOT_MIGRATABLE: ::std::os::raw::c_uint = 0;
pub const TSS_KEY_MIGRATABLE: ::std::os::raw::c_uint = 8;
pub const TSS_KEY_TYPE_DEFAULT: ::std::os::raw::c_uint = 0;
pub const TSS_KEY_TYPE_SIGNING: ::std::os::raw::c_uint = 16;
pub const TSS_KEY_TYPE_STORAGE: ::std::os::raw::c_uint = 32;
pub const TSS_KEY_TYPE_IDENTITY: ::std::os::raw::c_uint = 48;
pub const TSS_KEY_TYPE_AUTHCHANGE: ::std::os::raw::c_uint = 64;
pub const TSS_KEY_TYPE_BIND: ::std::os::raw::c_uint = 80;
pub const TSS_KEY_TYPE_LEGACY: ::std::os::raw::c_uint = 96;
pub const TSS_KEY_TYPE_MIGRATE: ::std::os::raw::c_uint = 112;
pub const TSS_KEY_TYPE_BITMASK: ::std::os::raw::c_uint = 240;
pub const TSS_KEY_EMPTY_KEY: ::std::os::raw::c_uint = 0;
pub const TSS_KEY_TSP_SRK: ::std::os::raw::c_uint = 67108864;
pub const TSS_KEY_TEMPLATE_BITMASK: ::std::os::raw::c_uint = 4227858432;
pub const TSS_ENCDATA_SEAL: ::std::os::raw::c_uint = 1;
pub const TSS_ENCDATA_BIND: ::std::os::raw::c_uint = 2;
pub const TSS_ENCDATA_LEGACY: ::std::os::raw::c_uint = 3;
pub const TSS_HASH_DEFAULT: ::std::os::raw::c_uint = 0;
pub const TSS_HASH_SHA1: ::std::os::raw::c_uint = 1;
pub const TSS_HASH_OTHER: ::std::os::raw::c_uint = 4294967295;
pub const TSS_POLICY_USAGE: ::std::os::raw::c_uint = 1;
pub const TSS_POLICY_MIGRATION: ::std::os::raw::c_uint = 2;
pub const TSS_POLICY_OPERATOR: ::std::os::raw::c_uint = 3;
pub const TSS_PCRS_STRUCT_DEFAULT: ::std::os::raw::c_uint = 0;
pub const TSS_PCRS_STRUCT_INFO: ::std::os::raw::c_uint = 1;
pub const TSS_PCRS_STRUCT_INFO_LONG: ::std::os::raw::c_uint = 2;
pub const TSS_PCRS_STRUCT_INFO_SHORT: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_CONTEXT_SILENT_MODE: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_CONTEXT_MACHINE_NAME: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_CONTEXT_VERSION_MODE: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_CONTEXT_TRANSPORT: ::std::os::raw::c_uint = 4;
pub const TSS_TSPATTRIB_CONTEXT_CONNECTION_VERSION: ::std::os::raw::c_uint =
    5;
pub const TSS_TSPATTRIB_SECRET_HASH_MODE: ::std::os::raw::c_uint = 6;
pub const TSS_TSPATTRIB_CONTEXTTRANS_CONTROL: ::std::os::raw::c_uint = 8;
pub const TSS_TSPATTRIB_CONTEXTTRANS_MODE: ::std::os::raw::c_uint = 16;
pub const TSS_TSPATTRIB_CONTEXT_NOT_SILENT: ::std::os::raw::c_uint = 0;
pub const TSS_TSPATTRIB_CONTEXT_SILENT: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_CONTEXT_VERSION_AUTO: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_CONTEXT_VERSION_V1_1: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_CONTEXT_VERSION_V1_2: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_DISABLE_TRANSPORT: ::std::os::raw::c_uint = 22;
pub const TSS_TSPATTRIB_ENABLE_TRANSPORT: ::std::os::raw::c_uint = 50;
pub const TSS_TSPATTRIB_TRANSPORT_NO_DEFAULT_ENCRYPTION:
          ::std::os::raw::c_uint =
    0;
pub const TSS_TSPATTRIB_TRANSPORT_DEFAULT_ENCRYPTION: ::std::os::raw::c_uint =
    1;
pub const TSS_TSPATTRIB_TRANSPORT_AUTHENTIC_CHANNEL: ::std::os::raw::c_uint =
    2;
pub const TSS_TSPATTRIB_TRANSPORT_EXCLUSIVE: ::std::os::raw::c_uint = 4;
pub const TSS_TSPATTRIB_TRANSPORT_STATIC_AUTH: ::std::os::raw::c_uint = 8;
pub const TSS_CONNECTION_VERSION_1_1: ::std::os::raw::c_uint = 1;
pub const TSS_CONNECTION_VERSION_1_2: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_SECRET_HASH_MODE_POPUP: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_HASH_MODE_NOT_NULL: ::std::os::raw::c_uint = 0;
pub const TSS_TSPATTRIB_HASH_MODE_NULL: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_TPM_CALLBACK_COLLATEIDENTITY: ::std::os::raw::c_uint =
    1;
pub const TSS_TSPATTRIB_TPM_CALLBACK_ACTIVATEIDENTITY: ::std::os::raw::c_uint
          =
    2;
pub const TSS_TSPATTRIB_TPM_ORDINAL_AUDIT_STATUS: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_TPM_CREDENTIAL: ::std::os::raw::c_uint = 4096;
pub const TPM_CAP_PROP_TPM_CLEAR_ORDINAL_AUDIT: ::std::os::raw::c_uint = 0;
pub const TPM_CAP_PROP_TPM_SET_ORDINAL_AUDIT: ::std::os::raw::c_uint = 1;
pub const TSS_TPMATTRIB_EKCERT: ::std::os::raw::c_uint = 1;
pub const TSS_TPMATTRIB_TPM_CC: ::std::os::raw::c_uint = 2;
pub const TSS_TPMATTRIB_PLATFORMCERT: ::std::os::raw::c_uint = 3;
pub const TSS_TPMATTRIB_PLATFORM_CC: ::std::os::raw::c_uint = 4;
pub const TSS_TSPATTRIB_POLICY_CALLBACK_HMAC: ::std::os::raw::c_uint = 128;
pub const TSS_TSPATTRIB_POLICY_CALLBACK_XOR_ENC: ::std::os::raw::c_uint = 256;
pub const TSS_TSPATTRIB_POLICY_CALLBACK_TAKEOWNERSHIP: ::std::os::raw::c_uint
          =
    384;
pub const TSS_TSPATTRIB_POLICY_CALLBACK_CHANGEAUTHASYM: ::std::os::raw::c_uint
          =
    512;
pub const TSS_TSPATTRIB_POLICY_SECRET_LIFETIME: ::std::os::raw::c_uint = 640;
pub const TSS_TSPATTRIB_POLICY_POPUPSTRING: ::std::os::raw::c_uint = 768;
pub const TSS_TSPATTRIB_POLICY_CALLBACK_SEALX_MASK: ::std::os::raw::c_uint =
    896;
pub const TSS_TSPATTRIB_POLICY_DELEGATION_INFO: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_POLICY_DELEGATION_PCR: ::std::os::raw::c_uint = 2;
pub const TSS_SECRET_LIFETIME_ALWAYS: ::std::os::raw::c_uint = 1;
pub const TSS_SECRET_LIFETIME_COUNTER: ::std::os::raw::c_uint = 2;
pub const TSS_SECRET_LIFETIME_TIMER: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_POLSECRET_LIFETIME_ALWAYS: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_POLSECRET_LIFETIME_COUNTER: ::std::os::raw::c_uint =
    2;
pub const TSS_TSPATTRIB_POLSECRET_LIFETIME_TIMER: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_POLICYSECRET_LIFETIME_ALWAYS: ::std::os::raw::c_uint =
    1;
pub const TSS_TSPATTRIB_POLICYSECRET_LIFETIME_COUNTER: ::std::os::raw::c_uint
          =
    2;
pub const TSS_TSPATTRIB_POLICYSECRET_LIFETIME_TIMER: ::std::os::raw::c_uint =
    3;
pub const TSS_TSPATTRIB_POLDEL_TYPE: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_POLDEL_INDEX: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_POLDEL_PER1: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_POLDEL_PER2: ::std::os::raw::c_uint = 4;
pub const TSS_TSPATTRIB_POLDEL_LABEL: ::std::os::raw::c_uint = 5;
pub const TSS_TSPATTRIB_POLDEL_FAMILYID: ::std::os::raw::c_uint = 6;
pub const TSS_TSPATTRIB_POLDEL_VERCOUNT: ::std::os::raw::c_uint = 7;
pub const TSS_TSPATTRIB_POLDEL_OWNERBLOB: ::std::os::raw::c_uint = 8;
pub const TSS_TSPATTRIB_POLDEL_KEYBLOB: ::std::os::raw::c_uint = 9;
pub const TSS_TSPATTRIB_POLDELPCR_LOCALITY: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_POLDELPCR_DIGESTATRELEASE: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_POLDELPCR_SELECTION: ::std::os::raw::c_uint = 3;
pub const TSS_DELEGATIONTYPE_NONE: ::std::os::raw::c_uint = 1;
pub const TSS_DELEGATIONTYPE_OWNER: ::std::os::raw::c_uint = 2;
pub const TSS_DELEGATIONTYPE_KEY: ::std::os::raw::c_uint = 3;
pub const TSS_SECRET_MODE_NONE: ::std::os::raw::c_uint = 2048;
pub const TSS_SECRET_MODE_SHA1: ::std::os::raw::c_uint = 4096;
pub const TSS_SECRET_MODE_PLAIN: ::std::os::raw::c_uint = 6144;
pub const TSS_SECRET_MODE_POPUP: ::std::os::raw::c_uint = 8192;
pub const TSS_SECRET_MODE_CALLBACK: ::std::os::raw::c_uint = 10240;
pub const TSS_TSPATTRIB_ENCDATA_BLOB: ::std::os::raw::c_uint = 8;
pub const TSS_TSPATTRIB_ENCDATA_PCR: ::std::os::raw::c_uint = 16;
pub const TSS_TSPATTRIB_ENCDATA_PCR_LONG: ::std::os::raw::c_uint = 24;
pub const TSS_TSPATTRIB_ENCDATA_SEAL: ::std::os::raw::c_uint = 32;
pub const TSS_TSPATTRIB_ENCDATABLOB_BLOB: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_ENCDATAPCR_DIGEST_ATCREATION: ::std::os::raw::c_uint =
    2;
pub const TSS_TSPATTRIB_ENCDATAPCR_DIGEST_ATRELEASE: ::std::os::raw::c_uint =
    3;
pub const TSS_TSPATTRIB_ENCDATAPCR_SELECTION: ::std::os::raw::c_uint = 4;
pub const TSS_TSPATTRIB_ENCDATAPCR_DIGEST_RELEASE: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_ENCDATAPCRLONG_LOCALITY_ATCREATION:
          ::std::os::raw::c_uint =
    5;
pub const TSS_TSPATTRIB_ENCDATAPCRLONG_LOCALITY_ATRELEASE:
          ::std::os::raw::c_uint =
    6;
pub const TSS_TSPATTRIB_ENCDATAPCRLONG_CREATION_SELECTION:
          ::std::os::raw::c_uint =
    7;
pub const TSS_TSPATTRIB_ENCDATAPCRLONG_RELEASE_SELECTION:
          ::std::os::raw::c_uint =
    8;
pub const TSS_TSPATTRIB_ENCDATAPCRLONG_DIGEST_ATCREATION:
          ::std::os::raw::c_uint =
    9;
pub const TSS_TSPATTRIB_ENCDATAPCRLONG_DIGEST_ATRELEASE:
          ::std::os::raw::c_uint =
    10;
pub const TSS_TSPATTRIB_ENCDATASEAL_PROTECT_MODE: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_ENCDATASEAL_NOPROTECT: ::std::os::raw::c_uint = 0;
pub const TSS_TSPATTRIB_ENCDATASEAL_PROTECT: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_ENCDATASEAL_NO_PROTECT: ::std::os::raw::c_uint = 0;
pub const TSS_TSPATTRIB_NV_INDEX: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_NV_PERMISSIONS: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_NV_STATE: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_NV_DATASIZE: ::std::os::raw::c_uint = 4;
pub const TSS_TSPATTRIB_NV_PCR: ::std::os::raw::c_uint = 5;
pub const TSS_TSPATTRIB_NVSTATE_READSTCLEAR: ::std::os::raw::c_uint = 1048576;
pub const TSS_TSPATTRIB_NVSTATE_WRITESTCLEAR: ::std::os::raw::c_uint =
    2097152;
pub const TSS_TSPATTRIB_NVSTATE_WRITEDEFINE: ::std::os::raw::c_uint = 3145728;
pub const TSS_TSPATTRIB_NVPCR_READPCRSELECTION: ::std::os::raw::c_uint =
    16777216;
pub const TSS_TSPATTRIB_NVPCR_READDIGESTATRELEASE: ::std::os::raw::c_uint =
    33554432;
pub const TSS_TSPATTRIB_NVPCR_READLOCALITYATRELEASE: ::std::os::raw::c_uint =
    50331648;
pub const TSS_TSPATTRIB_NVPCR_WRITEPCRSELECTION: ::std::os::raw::c_uint =
    67108864;
pub const TSS_TSPATTRIB_NVPCR_WRITEDIGESTATRELEASE: ::std::os::raw::c_uint =
    83886080;
pub const TSS_TSPATTRIB_NVPCR_WRITELOCALITYATRELEASE: ::std::os::raw::c_uint =
    100663296;
pub const TSS_NV_TPM: ::std::os::raw::c_uint = 2147483648;
pub const TSS_NV_PLATFORM: ::std::os::raw::c_uint = 1073741824;
pub const TSS_NV_USER: ::std::os::raw::c_uint = 536870912;
pub const TSS_NV_DEFINED: ::std::os::raw::c_uint = 268435456;
pub const TSS_NV_MASK_TPM: ::std::os::raw::c_uint = 2147483648;
pub const TSS_NV_MASK_PLATFORM: ::std::os::raw::c_uint = 1073741824;
pub const TSS_NV_MASK_USER: ::std::os::raw::c_uint = 536870912;
pub const TSS_NV_MASK_DEFINED: ::std::os::raw::c_uint = 268435456;
pub const TSS_NV_MASK_RESERVED: ::std::os::raw::c_uint = 251658240;
pub const TSS_NV_MASK_PURVIEW: ::std::os::raw::c_uint = 16711680;
pub const TSS_NV_MASK_INDEX: ::std::os::raw::c_uint = 65535;
pub const TSS_NV_INDEX_SESSIONS: ::std::os::raw::c_uint = 69889;
pub const TSS_MIGATTRIB_MIGRATIONBLOB: ::std::os::raw::c_uint = 16;
pub const TSS_MIGATTRIB_MIGRATIONTICKET: ::std::os::raw::c_uint = 32;
pub const TSS_MIGATTRIB_AUTHORITY_DATA: ::std::os::raw::c_uint = 48;
pub const TSS_MIGATTRIB_MIG_AUTH_DATA: ::std::os::raw::c_uint = 64;
pub const TSS_MIGATTRIB_TICKET_DATA: ::std::os::raw::c_uint = 80;
pub const TSS_MIGATTRIB_PAYLOAD_TYPE: ::std::os::raw::c_uint = 96;
pub const TSS_MIGATTRIB_MIGRATION_XOR_BLOB: ::std::os::raw::c_uint = 257;
pub const TSS_MIGATTRIB_MIGRATION_REWRAPPED_BLOB: ::std::os::raw::c_uint =
    258;
pub const TSS_MIGATTRIB_MIG_MSALIST_PUBKEY_BLOB: ::std::os::raw::c_uint = 259;
pub const TSS_MIGATTRIB_MIG_AUTHORITY_PUBKEY_BLOB: ::std::os::raw::c_uint =
    260;
pub const TSS_MIGATTRIB_MIG_DESTINATION_PUBKEY_BLOB: ::std::os::raw::c_uint =
    261;
pub const TSS_MIGATTRIB_MIG_SOURCE_PUBKEY_BLOB: ::std::os::raw::c_uint = 262;
pub const TSS_MIGATTRIB_MIG_REWRAPPED_BLOB: ::std::os::raw::c_uint = 258;
pub const TSS_MIGATTRIB_MIG_XOR_BLOB: ::std::os::raw::c_uint = 257;
pub const TSS_MIGATTRIB_AUTHORITY_DIGEST: ::std::os::raw::c_uint = 769;
pub const TSS_MIGATTRIB_AUTHORITY_APPROVAL_HMAC: ::std::os::raw::c_uint = 770;
pub const TSS_MIGATTRIB_AUTHORITY_MSALIST: ::std::os::raw::c_uint = 771;
pub const TSS_MIGATTRIB_MIG_AUTH_AUTHORITY_DIGEST: ::std::os::raw::c_uint =
    1025;
pub const TSS_MIGATTRIB_MIG_AUTH_DESTINATION_DIGEST: ::std::os::raw::c_uint =
    1026;
pub const TSS_MIGATTRIB_MIG_AUTH_SOURCE_DIGEST: ::std::os::raw::c_uint = 1027;
pub const TSS_MIGATTRIB_TICKET_SIG_DIGEST: ::std::os::raw::c_uint = 1281;
pub const TSS_MIGATTRIB_TICKET_SIG_VALUE: ::std::os::raw::c_uint = 1282;
pub const TSS_MIGATTRIB_TICKET_SIG_TICKET: ::std::os::raw::c_uint = 1283;
pub const TSS_MIGATTRIB_TICKET_RESTRICT_TICKET: ::std::os::raw::c_uint = 1284;
pub const TSS_MIGATTRIB_PT_MIGRATE_RESTRICTED: ::std::os::raw::c_uint = 1537;
pub const TSS_MIGATTRIB_PT_MIGRATE_EXTERNAL: ::std::os::raw::c_uint = 1538;
pub const TSS_TSPATTRIB_HASH_IDENTIFIER: ::std::os::raw::c_uint = 4096;
pub const TSS_TSPATTRIB_ALG_IDENTIFIER: ::std::os::raw::c_uint = 8192;
pub const TSS_TSPATTRIB_PCRS_INFO: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_PCRSINFO_PCRSTRUCT: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_DELFAMILY_STATE: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_DELFAMILY_INFO: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_DELFAMILYSTATE_LOCKED: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_DELFAMILYSTATE_ENABLED: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_DELFAMILYINFO_LABEL: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_DELFAMILYINFO_VERCOUNT: ::std::os::raw::c_uint = 4;
pub const TSS_TSPATTRIB_DELFAMILYINFO_FAMILYID: ::std::os::raw::c_uint = 5;
pub const TSS_TSPATTRIB_DAACRED_COMMIT: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_DAACRED_ATTRIB_GAMMAS: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_DAACRED_CREDENTIAL_BLOB: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_DAACRED_CALLBACK_SIGN: ::std::os::raw::c_uint = 4;
pub const TSS_TSPATTRIB_DAACRED_CALLBACK_VERIFYSIGNATURE:
          ::std::os::raw::c_uint =
    5;
pub const TSS_TSPATTRIB_DAACOMMIT_NUMBER: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_DAACOMMIT_SELECTION: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_DAACOMMIT_COMMITMENTS: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_DAAATTRIBGAMMAS_BLOB: ::std::os::raw::c_uint =
    4294967295;
pub const TSS_TSPATTRIB_DAAISSUERKEY_BLOB: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_DAAISSUERKEY_PUBKEY: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_DAAISSUERKEYBLOB_PUBLIC_KEY: ::std::os::raw::c_uint =
    1;
pub const TSS_TSPATTRIB_DAAISSUERKEYBLOB_SECRET_KEY: ::std::os::raw::c_uint =
    2;
pub const TSS_TSPATTRIB_DAAISSUERKEYBLOB_KEYBLOB: ::std::os::raw::c_uint = 3;
pub const TSS_TSPATTRIB_DAAISSUERKEYBLOB_PROOF: ::std::os::raw::c_uint = 4;
pub const TSS_TSPATTRIB_DAAISSUERKEYPUBKEY_NUM_ATTRIBS: ::std::os::raw::c_uint
          =
    1;
pub const TSS_TSPATTRIB_DAAISSUERKEYPUBKEY_NUM_PLATFORM_ATTRIBS:
          ::std::os::raw::c_uint =
    2;
pub const TSS_TSPATTRIB_DAAISSUERKEYPUBKEY_NUM_ISSUER_ATTRIBS:
          ::std::os::raw::c_uint =
    3;
pub const TSS_TSPATTRIB_DAAARAKEY_BLOB: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_DAAARAKEYBLOB_PUBLIC_KEY: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_DAAARAKEYBLOB_SECRET_KEY: ::std::os::raw::c_uint = 2;
pub const TSS_TSPATTRIB_DAAARAKEYBLOB_KEYBLOB: ::std::os::raw::c_uint = 3;
pub const TSS_FLAG_DAA_PSEUDONYM_PLAIN: ::std::os::raw::c_uint = 0;
pub const TSS_FLAG_DAA_PSEUDONYM_ENCRYPTED: ::std::os::raw::c_uint = 1;
pub const TSS_TSPATTRIB_KEY_BLOB: ::std::os::raw::c_uint = 64;
pub const TSS_TSPATTRIB_KEY_INFO: ::std::os::raw::c_uint = 128;
pub const TSS_TSPATTRIB_KEY_UUID: ::std::os::raw::c_uint = 192;
pub const TSS_TSPATTRIB_KEY_PCR: ::std::os::raw::c_uint = 256;
pub const TSS_TSPATTRIB_RSAKEY_INFO: ::std::os::raw::c_uint = 320;
pub const TSS_TSPATTRIB_KEY_REGISTER: ::std::os::raw::c_uint = 384;
pub const TSS_TSPATTRIB_KEY_PCR_LONG: ::std::os::raw::c_uint = 448;
pub const TSS_TSPATTRIB_KEY_CONTROLBIT: ::std::os::raw::c_uint = 512;
pub const TSS_TSPATTRIB_KEY_CMKINFO: ::std::os::raw::c_uint = 1024;
pub const TSS_TSPATTRIB_KEYBLOB_BLOB: ::std::os::raw::c_uint = 8;
pub const TSS_TSPATTRIB_KEYBLOB_PUBLIC_KEY: ::std::os::raw::c_uint = 16;
pub const TSS_TSPATTRIB_KEYBLOB_PRIVATE_KEY: ::std::os::raw::c_uint = 40;
pub const TSS_TSPATTRIB_KEYINFO_SIZE: ::std::os::raw::c_uint = 128;
pub const TSS_TSPATTRIB_KEYINFO_USAGE: ::std::os::raw::c_uint = 256;
pub const TSS_TSPATTRIB_KEYINFO_KEYFLAGS: ::std::os::raw::c_uint = 384;
pub const TSS_TSPATTRIB_KEYINFO_AUTHUSAGE: ::std::os::raw::c_uint = 512;
pub const TSS_TSPATTRIB_KEYINFO_ALGORITHM: ::std::os::raw::c_uint = 640;
pub const TSS_TSPATTRIB_KEYINFO_SIGSCHEME: ::std::os::raw::c_uint = 768;
pub const TSS_TSPATTRIB_KEYINFO_ENCSCHEME: ::std::os::raw::c_uint = 896;
pub const TSS_TSPATTRIB_KEYINFO_MIGRATABLE: ::std::os::raw::c_uint = 1024;
pub const TSS_TSPATTRIB_KEYINFO_REDIRECTED: ::std::os::raw::c_uint = 1152;
pub const TSS_TSPATTRIB_KEYINFO_VOLATILE: ::std::os::raw::c_uint = 1280;
pub const TSS_TSPATTRIB_KEYINFO_AUTHDATAUSAGE: ::std::os::raw::c_uint = 1408;
pub const TSS_TSPATTRIB_KEYINFO_VERSION: ::std::os::raw::c_uint = 1536;
pub const TSS_TSPATTRIB_KEYINFO_CMK: ::std::os::raw::c_uint = 1664;
pub const TSS_TSPATTRIB_KEYINFO_KEYSTRUCT: ::std::os::raw::c_uint = 1792;
pub const TSS_TSPATTRIB_KEYCONTROL_OWNEREVICT: ::std::os::raw::c_uint = 1920;
pub const TSS_TSPATTRIB_KEYINFO_RSA_EXPONENT: ::std::os::raw::c_uint = 4096;
pub const TSS_TSPATTRIB_KEYINFO_RSA_MODULUS: ::std::os::raw::c_uint = 8192;
pub const TSS_TSPATTRIB_KEYINFO_RSA_KEYSIZE: ::std::os::raw::c_uint = 12288;
pub const TSS_TSPATTRIB_KEYINFO_RSA_PRIMES: ::std::os::raw::c_uint = 16384;
pub const TSS_TSPATTRIB_KEYPCR_DIGEST_ATCREATION: ::std::os::raw::c_uint =
    32768;
pub const TSS_TSPATTRIB_KEYPCR_DIGEST_ATRELEASE: ::std::os::raw::c_uint =
    65536;
pub const TSS_TSPATTRIB_KEYPCR_SELECTION: ::std::os::raw::c_uint = 98304;
pub const TSS_TSPATTRIB_KEYREGISTER_USER: ::std::os::raw::c_uint = 33554432;
pub const TSS_TSPATTRIB_KEYREGISTER_SYSTEM: ::std::os::raw::c_uint = 67108864;
pub const TSS_TSPATTRIB_KEYREGISTER_NO: ::std::os::raw::c_uint = 100663296;
pub const TSS_TSPATTRIB_KEYPCRLONG_LOCALITY_ATCREATION: ::std::os::raw::c_uint
          =
    262144;
pub const TSS_TSPATTRIB_KEYPCRLONG_LOCALITY_ATRELEASE: ::std::os::raw::c_uint
          =
    524288;
pub const TSS_TSPATTRIB_KEYPCRLONG_CREATION_SELECTION: ::std::os::raw::c_uint
          =
    786432;
pub const TSS_TSPATTRIB_KEYPCRLONG_RELEASE_SELECTION: ::std::os::raw::c_uint =
    1048576;
pub const TSS_TSPATTRIB_KEYPCRLONG_DIGEST_ATCREATION: ::std::os::raw::c_uint =
    1310720;
pub const TSS_TSPATTRIB_KEYPCRLONG_DIGEST_ATRELEASE: ::std::os::raw::c_uint =
    1572864;
pub const TSS_TSPATTRIB_KEYINFO_CMK_MA_APPROVAL: ::std::os::raw::c_uint = 16;
pub const TSS_TSPATTRIB_KEYINFO_CMK_MA_DIGEST: ::std::os::raw::c_uint = 32;
pub const TSS_KEY_SIZEVAL_512BIT: ::std::os::raw::c_uint = 512;
pub const TSS_KEY_SIZEVAL_1024BIT: ::std::os::raw::c_uint = 1024;
pub const TSS_KEY_SIZEVAL_2048BIT: ::std::os::raw::c_uint = 2048;
pub const TSS_KEY_SIZEVAL_4096BIT: ::std::os::raw::c_uint = 4096;
pub const TSS_KEY_SIZEVAL_8192BIT: ::std::os::raw::c_uint = 8192;
pub const TSS_KEY_SIZEVAL_16384BIT: ::std::os::raw::c_uint = 16384;
pub const TSS_KEYUSAGE_BIND: ::std::os::raw::c_uint = 0;
pub const TSS_KEYUSAGE_IDENTITY: ::std::os::raw::c_uint = 1;
pub const TSS_KEYUSAGE_LEGACY: ::std::os::raw::c_uint = 2;
pub const TSS_KEYUSAGE_SIGN: ::std::os::raw::c_uint = 3;
pub const TSS_KEYUSAGE_STORAGE: ::std::os::raw::c_uint = 4;
pub const TSS_KEYUSAGE_AUTHCHANGE: ::std::os::raw::c_uint = 5;
pub const TSS_KEYUSAGE_MIGRATE: ::std::os::raw::c_uint = 6;
pub const TSS_KEYFLAG_REDIRECTION: ::std::os::raw::c_uint = 1;
pub const TSS_KEYFLAG_MIGRATABLE: ::std::os::raw::c_uint = 2;
pub const TSS_KEYFLAG_VOLATILEKEY: ::std::os::raw::c_uint = 4;
pub const TSS_KEYFLAG_CERTIFIED_MIGRATABLE: ::std::os::raw::c_uint = 8;
pub const TSS_ALG_RSA: ::std::os::raw::c_uint = 32;
pub const TSS_ALG_DES: ::std::os::raw::c_uint = 33;
pub const TSS_ALG_3DES: ::std::os::raw::c_uint = 34;
pub const TSS_ALG_SHA: ::std::os::raw::c_uint = 35;
pub const TSS_ALG_HMAC: ::std::os::raw::c_uint = 36;
pub const TSS_ALG_AES128: ::std::os::raw::c_uint = 37;
pub const TSS_ALG_AES192: ::std::os::raw::c_uint = 38;
pub const TSS_ALG_AES256: ::std::os::raw::c_uint = 39;
pub const TSS_ALG_XOR: ::std::os::raw::c_uint = 40;
pub const TSS_ALG_MGF1: ::std::os::raw::c_uint = 41;
pub const TSS_ALG_AES: ::std::os::raw::c_uint = 37;
pub const TSS_ALG_DEFAULT: ::std::os::raw::c_uint = 254;
pub const TSS_ALG_DEFAULT_SIZE: ::std::os::raw::c_uint = 255;
pub const TSS_SS_NONE: ::std::os::raw::c_uint = 16;
pub const TSS_SS_RSASSAPKCS1V15_SHA1: ::std::os::raw::c_uint = 17;
pub const TSS_SS_RSASSAPKCS1V15_DER: ::std::os::raw::c_uint = 18;
pub const TSS_SS_RSASSAPKCS1V15_INFO: ::std::os::raw::c_uint = 19;
pub const TSS_ES_NONE: ::std::os::raw::c_uint = 16;
pub const TSS_ES_RSAESPKCSV15: ::std::os::raw::c_uint = 17;
pub const TSS_ES_RSAESOAEP_SHA1_MGF1: ::std::os::raw::c_uint = 18;
pub const TSS_ES_SYM_CNT: ::std::os::raw::c_uint = 19;
pub const TSS_ES_SYM_OFB: ::std::os::raw::c_uint = 20;
pub const TSS_ES_SYM_CBC_PKCS5PAD: ::std::os::raw::c_uint = 21;
pub const TSS_PS_TYPE_USER: ::std::os::raw::c_uint = 1;
pub const TSS_PS_TYPE_SYSTEM: ::std::os::raw::c_uint = 2;
pub const TSS_MS_MIGRATE: ::std::os::raw::c_uint = 32;
pub const TSS_MS_REWRAP: ::std::os::raw::c_uint = 33;
pub const TSS_MS_MAINT: ::std::os::raw::c_uint = 34;
pub const TSS_MS_RESTRICT_MIGRATE: ::std::os::raw::c_uint = 35;
pub const TSS_MS_RESTRICT_APPROVE_DOUBLE: ::std::os::raw::c_uint = 36;
pub const TSS_MS_RESTRICT_MIGRATE_EXTERNAL: ::std::os::raw::c_uint = 37;
pub const TSS_KEYAUTH_AUTH_NEVER: ::std::os::raw::c_uint = 16;
pub const TSS_KEYAUTH_AUTH_ALWAYS: ::std::os::raw::c_uint = 17;
pub const TSS_KEYAUTH_AUTH_PRIV_USE_ONLY: ::std::os::raw::c_uint = 18;
pub const TSS_TPMSTATUS_DISABLEOWNERCLEAR: ::std::os::raw::c_uint = 1;
pub const TSS_TPMSTATUS_DISABLEFORCECLEAR: ::std::os::raw::c_uint = 2;
pub const TSS_TPMSTATUS_DISABLED: ::std::os::raw::c_uint = 3;
pub const TSS_TPMSTATUS_DEACTIVATED: ::std::os::raw::c_uint = 4;
pub const TSS_TPMSTATUS_OWNERSETDISABLE: ::std::os::raw::c_uint = 5;
pub const TSS_TPMSTATUS_SETOWNERINSTALL: ::std::os::raw::c_uint = 6;
pub const TSS_TPMSTATUS_DISABLEPUBEKREAD: ::std::os::raw::c_uint = 7;
pub const TSS_TPMSTATUS_ALLOWMAINTENANCE: ::std::os::raw::c_uint = 8;
pub const TSS_TPMSTATUS_PHYSPRES_LIFETIMELOCK: ::std::os::raw::c_uint = 9;
pub const TSS_TPMSTATUS_PHYSPRES_HWENABLE: ::std::os::raw::c_uint = 10;
pub const TSS_TPMSTATUS_PHYSPRES_CMDENABLE: ::std::os::raw::c_uint = 11;
pub const TSS_TPMSTATUS_PHYSPRES_LOCK: ::std::os::raw::c_uint = 12;
pub const TSS_TPMSTATUS_PHYSPRESENCE: ::std::os::raw::c_uint = 13;
pub const TSS_TPMSTATUS_PHYSICALDISABLE: ::std::os::raw::c_uint = 14;
pub const TSS_TPMSTATUS_CEKP_USED: ::std::os::raw::c_uint = 15;
pub const TSS_TPMSTATUS_PHYSICALSETDEACTIVATED: ::std::os::raw::c_uint = 16;
pub const TSS_TPMSTATUS_SETTEMPDEACTIVATED: ::std::os::raw::c_uint = 17;
pub const TSS_TPMSTATUS_POSTINITIALISE: ::std::os::raw::c_uint = 18;
pub const TSS_TPMSTATUS_TPMPOST: ::std::os::raw::c_uint = 19;
pub const TSS_TPMSTATUS_TPMPOSTLOCK: ::std::os::raw::c_uint = 20;
pub const TSS_TPMSTATUS_DISABLEPUBSRKREAD: ::std::os::raw::c_uint = 22;
pub const TSS_TPMSTATUS_MAINTENANCEUSED: ::std::os::raw::c_uint = 23;
pub const TSS_TPMSTATUS_OPERATORINSTALLED: ::std::os::raw::c_uint = 24;
pub const TSS_TPMSTATUS_OPERATOR_INSTALLED: ::std::os::raw::c_uint = 24;
pub const TSS_TPMSTATUS_FIPS: ::std::os::raw::c_uint = 25;
pub const TSS_TPMSTATUS_ENABLEREVOKEEK: ::std::os::raw::c_uint = 26;
pub const TSS_TPMSTATUS_ENABLE_REVOKEEK: ::std::os::raw::c_uint = 26;
pub const TSS_TPMSTATUS_NV_LOCK: ::std::os::raw::c_uint = 27;
pub const TSS_TPMSTATUS_TPM_ESTABLISHED: ::std::os::raw::c_uint = 28;
pub const TSS_TPMSTATUS_RESETLOCK: ::std::os::raw::c_uint = 29;
pub const TSS_TPMSTATUS_DISABLE_FULL_DA_LOGIC_INFO: ::std::os::raw::c_uint =
    29;
pub const TSS_TPMCAP_ORD: ::std::os::raw::c_uint = 16;
pub const TSS_TPMCAP_ALG: ::std::os::raw::c_uint = 17;
pub const TSS_TPMCAP_FLAG: ::std::os::raw::c_uint = 18;
pub const TSS_TPMCAP_PROPERTY: ::std::os::raw::c_uint = 19;
pub const TSS_TPMCAP_VERSION: ::std::os::raw::c_uint = 20;
pub const TSS_TPMCAP_VERSION_VAL: ::std::os::raw::c_uint = 21;
pub const TSS_TPMCAP_NV_LIST: ::std::os::raw::c_uint = 22;
pub const TSS_TPMCAP_NV_INDEX: ::std::os::raw::c_uint = 23;
pub const TSS_TPMCAP_MFR: ::std::os::raw::c_uint = 24;
pub const TSS_TPMCAP_SYM_MODE: ::std::os::raw::c_uint = 25;
pub const TSS_TPMCAP_HANDLE: ::std::os::raw::c_uint = 26;
pub const TSS_TPMCAP_TRANS_ES: ::std::os::raw::c_uint = 27;
pub const TSS_TPMCAP_AUTH_ENCRYPT: ::std::os::raw::c_uint = 28;
pub const TSS_TPMCAP_SET_PERM_FLAGS: ::std::os::raw::c_uint = 29;
pub const TSS_TPMCAP_SET_VENDOR: ::std::os::raw::c_uint = 30;
pub const TSS_TPMCAP_DA_LOGIC: ::std::os::raw::c_uint = 31;
pub const TSS_TPMCAP_PROP_PCR: ::std::os::raw::c_uint = 16;
pub const TSS_TPMCAP_PROP_DIR: ::std::os::raw::c_uint = 17;
pub const TSS_TPMCAP_PROP_MANUFACTURER: ::std::os::raw::c_uint = 18;
pub const TSS_TPMCAP_PROP_SLOTS: ::std::os::raw::c_uint = 19;
pub const TSS_TPMCAP_PROP_KEYS: ::std::os::raw::c_uint = 19;
pub const TSS_TPMCAP_PROP_FAMILYROWS: ::std::os::raw::c_uint = 20;
pub const TSS_TPMCAP_PROP_DELEGATEROWS: ::std::os::raw::c_uint = 21;
pub const TSS_TPMCAP_PROP_OWNER: ::std::os::raw::c_uint = 22;
pub const TSS_TPMCAP_PROP_MAXKEYS: ::std::os::raw::c_uint = 24;
pub const TSS_TPMCAP_PROP_AUTHSESSIONS: ::std::os::raw::c_uint = 25;
pub const TSS_TPMCAP_PROP_MAXAUTHSESSIONS: ::std::os::raw::c_uint = 26;
pub const TSS_TPMCAP_PROP_TRANSESSIONS: ::std::os::raw::c_uint = 27;
pub const TSS_TPMCAP_PROP_MAXTRANSESSIONS: ::std::os::raw::c_uint = 28;
pub const TSS_TPMCAP_PROP_SESSIONS: ::std::os::raw::c_uint = 29;
pub const TSS_TPMCAP_PROP_MAXSESSIONS: ::std::os::raw::c_uint = 30;
pub const TSS_TPMCAP_PROP_CONTEXTS: ::std::os::raw::c_uint = 31;
pub const TSS_TPMCAP_PROP_MAXCONTEXTS: ::std::os::raw::c_uint = 32;
pub const TSS_TPMCAP_PROP_DAASESSIONS: ::std::os::raw::c_uint = 33;
pub const TSS_TPMCAP_PROP_MAXDAASESSIONS: ::std::os::raw::c_uint = 34;
pub const TSS_TPMCAP_PROP_DAA_INTERRUPT: ::std::os::raw::c_uint = 35;
pub const TSS_TPMCAP_PROP_COUNTERS: ::std::os::raw::c_uint = 36;
pub const TSS_TPMCAP_PROP_MAXCOUNTERS: ::std::os::raw::c_uint = 37;
pub const TSS_TPMCAP_PROP_ACTIVECOUNTER: ::std::os::raw::c_uint = 38;
pub const TSS_TPMCAP_PROP_MIN_COUNTER: ::std::os::raw::c_uint = 39;
pub const TSS_TPMCAP_PROP_TISTIMEOUTS: ::std::os::raw::c_uint = 40;
pub const TSS_TPMCAP_PROP_STARTUPEFFECTS: ::std::os::raw::c_uint = 41;
pub const TSS_TPMCAP_PROP_MAXCONTEXTCOUNTDIST: ::std::os::raw::c_uint = 42;
pub const TSS_TPMCAP_PROP_CMKRESTRICTION: ::std::os::raw::c_uint = 43;
pub const TSS_TPMCAP_PROP_DURATION: ::std::os::raw::c_uint = 44;
pub const TSS_TPMCAP_PROP_MAXNVAVAILABLE: ::std::os::raw::c_uint = 45;
pub const TSS_TPMCAP_PROP_INPUTBUFFERSIZE: ::std::os::raw::c_uint = 46;
pub const TSS_TPMCAP_PROP_REVISION: ::std::os::raw::c_uint = 47;
pub const TSS_TPMCAP_PROP_LOCALITIES_AVAIL: ::std::os::raw::c_uint = 50;
pub const TSS_TCSCAP_ALG: ::std::os::raw::c_uint = 1;
pub const TSS_TCSCAP_VERSION: ::std::os::raw::c_uint = 2;
pub const TSS_TCSCAP_CACHING: ::std::os::raw::c_uint = 3;
pub const TSS_TCSCAP_PERSSTORAGE: ::std::os::raw::c_uint = 4;
pub const TSS_TCSCAP_MANUFACTURER: ::std::os::raw::c_uint = 5;
pub const TSS_TCSCAP_PLATFORM_CLASS: ::std::os::raw::c_uint = 6;
pub const TSS_TCSCAP_TRANSPORT: ::std::os::raw::c_uint = 7;
pub const TSS_TCSCAP_PLATFORM_INFO: ::std::os::raw::c_uint = 8;
pub const TSS_TCSCAP_PROP_KEYCACHE: ::std::os::raw::c_uint = 256;
pub const TSS_TCSCAP_PROP_AUTHCACHE: ::std::os::raw::c_uint = 257;
pub const TSS_TCSCAP_PROP_MANUFACTURER_STR: ::std::os::raw::c_uint = 258;
pub const TSS_TCSCAP_PROP_MANUFACTURER_ID: ::std::os::raw::c_uint = 259;
pub const TSS_TCSCAP_PLATFORM_VERSION: ::std::os::raw::c_uint = 4352;
pub const TSS_TCSCAP_PLATFORM_TYPE: ::std::os::raw::c_uint = 4353;
pub const TSS_TCSCAP_TRANS_EXCLUSIVE: ::std::os::raw::c_uint = 8448;
pub const TSS_TCSCAP_PROP_HOST_PLATFORM: ::std::os::raw::c_uint = 12289;
pub const TSS_TCSCAP_PROP_ALL_PLATFORMS: ::std::os::raw::c_uint = 12290;
pub const TSS_TSPCAP_ALG: ::std::os::raw::c_uint = 16;
pub const TSS_TSPCAP_VERSION: ::std::os::raw::c_uint = 17;
pub const TSS_TSPCAP_PERSSTORAGE: ::std::os::raw::c_uint = 18;
pub const TSS_TSPCAP_MANUFACTURER: ::std::os::raw::c_uint = 19;
pub const TSS_TSPCAP_RETURNVALUE_INFO: ::std::os::raw::c_uint = 21;
pub const TSS_TSPCAP_PLATFORM_INFO: ::std::os::raw::c_uint = 22;
pub const TSS_TSPCAP_PROP_MANUFACTURER_STR: ::std::os::raw::c_uint = 258;
pub const TSS_TSPCAP_PROP_MANUFACTURER_ID: ::std::os::raw::c_uint = 259;
pub const TSS_TSPCAP_PLATFORM_TYPE: ::std::os::raw::c_uint = 513;
pub const TSS_TSPCAP_PLATFORM_VERSION: ::std::os::raw::c_uint = 514;
pub const TSS_TSPCAP_PROP_RETURNVALUE_INFO: ::std::os::raw::c_uint = 513;
pub const TSS_EV_CODE_CERT: ::std::os::raw::c_uint = 1;
pub const TSS_EV_CODE_NOCERT: ::std::os::raw::c_uint = 2;
pub const TSS_EV_XML_CONFIG: ::std::os::raw::c_uint = 3;
pub const TSS_EV_NO_ACTION: ::std::os::raw::c_uint = 4;
pub const TSS_EV_SEPARATOR: ::std::os::raw::c_uint = 5;
pub const TSS_EV_ACTION: ::std::os::raw::c_uint = 6;
pub const TSS_EV_PLATFORM_SPECIFIC: ::std::os::raw::c_uint = 7;
pub const TSS_TSPCAP_RANDOMLIMIT: ::std::os::raw::c_uint = 4096;
pub const TSS_BLOB_STRUCT_VERSION: ::std::os::raw::c_uint = 1;
pub const TSS_BLOB_TYPE_KEY: ::std::os::raw::c_uint = 1;
pub const TSS_BLOB_TYPE_PUBKEY: ::std::os::raw::c_uint = 2;
pub const TSS_BLOB_TYPE_MIGKEY: ::std::os::raw::c_uint = 3;
pub const TSS_BLOB_TYPE_SEALEDDATA: ::std::os::raw::c_uint = 4;
pub const TSS_BLOB_TYPE_BOUNDDATA: ::std::os::raw::c_uint = 5;
pub const TSS_BLOB_TYPE_MIGTICKET: ::std::os::raw::c_uint = 6;
pub const TSS_BLOB_TYPE_PRIVATEKEY: ::std::os::raw::c_uint = 7;
pub const TSS_BLOB_TYPE_PRIVATEKEY_MOD1: ::std::os::raw::c_uint = 8;
pub const TSS_BLOB_TYPE_RANDOM_XOR: ::std::os::raw::c_uint = 9;
pub const TSS_BLOB_TYPE_CERTIFY_INFO: ::std::os::raw::c_uint = 10;
pub const TSS_BLOB_TYPE_KEY_1_2: ::std::os::raw::c_uint = 11;
pub const TSS_BLOB_TYPE_CERTIFY_INFO_2: ::std::os::raw::c_uint = 12;
pub const TSS_BLOB_TYPE_CMK_MIG_KEY: ::std::os::raw::c_uint = 13;
pub const TSS_BLOB_TYPE_CMK_BYTE_STREAM: ::std::os::raw::c_uint = 14;
pub const TSS_DAA_LENGTH_N: ::std::os::raw::c_uint = 256;
pub const TSS_DAA_LENGTH_F: ::std::os::raw::c_uint = 13;
pub const TSS_DAA_LENGTH_E: ::std::os::raw::c_uint = 46;
pub const TSS_DAA_LENGTH_E_PRIME: ::std::os::raw::c_uint = 15;
pub const TSS_DAA_LENGTH_V: ::std::os::raw::c_uint = 317;
pub const TSS_DAA_LENGTH_SAFETY: ::std::os::raw::c_uint = 10;
pub const TSS_DAA_LENGTH_HASH: ::std::os::raw::c_uint = 20;
pub const TSS_DAA_LENGTH_S: ::std::os::raw::c_uint = 128;
pub const TSS_DAA_LENGTH_GAMMA: ::std::os::raw::c_uint = 204;
pub const TSS_DAA_LENGTH_RHO: ::std::os::raw::c_uint = 26;
pub const TSS_DAA_LENGTH_MFG1_GAMMA: ::std::os::raw::c_uint = 214;
pub const TSS_DAA_LENGTH_MGF1_AR: ::std::os::raw::c_uint = 25;
pub const TDDL_CAP_VERSION: ::std::os::raw::c_uint = 256;
pub const TDDL_CAP_VER_DRV: ::std::os::raw::c_uint = 257;
pub const TDDL_CAP_VER_FW: ::std::os::raw::c_uint = 258;
pub const TDDL_CAP_VER_FW_DATE: ::std::os::raw::c_uint = 259;
pub const TDDL_CAP_PROPERTY: ::std::os::raw::c_uint = 512;
pub const TDDL_CAP_PROP_MANUFACTURER: ::std::os::raw::c_uint = 513;
pub const TDDL_CAP_PROP_MODULE_TYPE: ::std::os::raw::c_uint = 514;
pub const TDDL_CAP_PROP_GLOBAL_STATE: ::std::os::raw::c_uint = 515;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type BYTE = u8;
pub type TSS_BOOL = i8;
pub type UINT16 = u16;
pub type UINT32 = u32;
pub type UINT64 = u64;
pub type TSS_UNICODE = u16;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type TPM_BOOL = BYTE;
pub type TPM_LOCALITY_MODIFIER = BYTE;
pub type TPM_COMMAND_CODE = UINT32;
pub type TPM_COUNT_ID = UINT32;
pub type TPM_REDIT_COMMAND = UINT32;
pub type TPM_HANDLE = UINT32;
pub type TPM_AUTHHANDLE = UINT32;
pub type TPM_TRANSHANDLE = UINT32;
pub type TPM_KEYHANDLE = UINT32;
pub type TPM_DIRINDEX = UINT32;
pub type TPM_PCRINDEX = UINT32;
pub type TPM_RESULT = UINT32;
pub type TPM_MODIFIER_INDICATOR = UINT32;
pub type TPM_STRUCTURE_TAG = UINT16;
pub type TPM_RESOURCE_TYPE = UINT32;
pub type TPM_PAYLOAD_TYPE = BYTE;
pub type TPM_ENTITY_TYPE = UINT16;
pub type TPM_KEY_HANDLE = UINT32;
pub type TPM_STARTUP_TYPE = UINT16;
pub type TPM_PROTOCOL_ID = UINT16;
pub type TPM_ALGORITHM_ID = UINT32;
pub type TPM_PHYSICAL_PRESENCE = UINT16;
pub type TPM_MIGRATE_SCHEME = UINT16;
pub type TPM_EK_TYPE = UINT16;
pub type TPM_PLATFORM_SPECIFIC = UINT16;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_STRUCT_VER {
    pub major: BYTE,
    pub minor: BYTE,
    pub revMajor: BYTE,
    pub revMinor: BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_STRUCT_VER() {
    assert_eq!(::std::mem::size_of::<tdTPM_STRUCT_VER>() , 4usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_STRUCT_VER ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_STRUCT_VER>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( tdTPM_STRUCT_VER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STRUCT_VER ) ) . major as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STRUCT_VER ) ,
                "::" , stringify ! ( major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STRUCT_VER ) ) . minor as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STRUCT_VER ) ,
                "::" , stringify ! ( minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STRUCT_VER ) ) . revMajor as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STRUCT_VER ) ,
                "::" , stringify ! ( revMajor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STRUCT_VER ) ) . revMinor as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STRUCT_VER ) ,
                "::" , stringify ! ( revMinor ) ));
}
impl Clone for tdTPM_STRUCT_VER {
    fn clone(&self) -> Self { *self }
}
pub type TPM_STRUCT_VER = tdTPM_STRUCT_VER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_VERSION_BYTE {
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 3usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_tdTPM_VERSION_BYTE() {
    assert_eq!(::std::mem::size_of::<tdTPM_VERSION_BYTE>() , 4usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_VERSION_BYTE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_VERSION_BYTE>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_VERSION_BYTE ) ));
}
impl Clone for tdTPM_VERSION_BYTE {
    fn clone(&self) -> Self { *self }
}
impl tdTPM_VERSION_BYTE {
    #[inline]
    pub fn leastSigVer(&self) -> ::std::os::raw::c_int {
        let mask = 15usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_leastSigVer(&mut self, val: ::std::os::raw::c_int) {
        let mask = 15usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn mostSigVer(&self) -> ::std::os::raw::c_int {
        let mask = 240usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mostSigVer(&mut self, val: ::std::os::raw::c_int) {
        let mask = 240usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(leastSigVer: ::std::os::raw::c_int,
                          mostSigVer: ::std::os::raw::c_int) -> u8 {
        ({
             ({ 0 } |
                  ((leastSigVer as u32 as u8) << 0usize) & (15usize as u8))
         } | ((mostSigVer as u32 as u8) << 4usize) & (240usize as u8))
    }
}
pub type TPM_VERSION_BYTE = tdTPM_VERSION_BYTE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_VERSION {
    pub major: BYTE,
    pub minor: BYTE,
    pub revMajor: BYTE,
    pub revMinor: BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_VERSION() {
    assert_eq!(::std::mem::size_of::<tdTPM_VERSION>() , 4usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_VERSION ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_VERSION>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_VERSION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_VERSION ) ) . major as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_VERSION ) , "::"
                , stringify ! ( major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_VERSION ) ) . minor as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_VERSION ) , "::"
                , stringify ! ( minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_VERSION ) ) . revMajor as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_VERSION ) , "::"
                , stringify ! ( revMajor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_VERSION ) ) . revMinor as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_VERSION ) , "::"
                , stringify ! ( revMinor ) ));
}
impl Clone for tdTPM_VERSION {
    fn clone(&self) -> Self { *self }
}
pub type TPM_VERSION = tdTPM_VERSION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DIGEST {
    pub digest: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout_tdTPM_DIGEST() {
    assert_eq!(::std::mem::size_of::<tdTPM_DIGEST>() , 20usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_DIGEST ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DIGEST>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_DIGEST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DIGEST ) ) . digest as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DIGEST ) , "::" ,
                stringify ! ( digest ) ));
}
impl Clone for tdTPM_DIGEST {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DIGEST = tdTPM_DIGEST;
pub type TPM_CHOSENID_HASH = TPM_DIGEST;
pub type TPM_COMPOSITE_HASH = TPM_DIGEST;
pub type TPM_DIRVALUE = TPM_DIGEST;
pub type TPM_HMAC = TPM_DIGEST;
pub type TPM_PCRVALUE = TPM_DIGEST;
pub type TPM_AUDITDIGEST = TPM_DIGEST;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_NONCE {
    pub nonce: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout_tdTPM_NONCE() {
    assert_eq!(::std::mem::size_of::<tdTPM_NONCE>() , 20usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_NONCE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_NONCE>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_NONCE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NONCE ) ) . nonce as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NONCE ) , "::" ,
                stringify ! ( nonce ) ));
}
impl Clone for tdTPM_NONCE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_NONCE = tdTPM_NONCE;
pub type TPM_DAA_TPM_SEED = TPM_NONCE;
pub type TPM_DAA_CONTEXT_SEED = TPM_NONCE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_AUTHDATA {
    pub authdata: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout_tdTPM_AUTHDATA() {
    assert_eq!(::std::mem::size_of::<tdTPM_AUTHDATA>() , 20usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_AUTHDATA ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_AUTHDATA>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_AUTHDATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_AUTHDATA ) ) . authdata as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_AUTHDATA ) , "::"
                , stringify ! ( authdata ) ));
}
impl Clone for tdTPM_AUTHDATA {
    fn clone(&self) -> Self { *self }
}
pub type TPM_AUTHDATA = tdTPM_AUTHDATA;
pub type TPM_SECRET = TPM_AUTHDATA;
pub type TPM_ENCAUTH = TPM_AUTHDATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_KEY_HANDLE_LIST {
    pub loaded: UINT16,
    pub handle: *mut TPM_KEY_HANDLE,
}
#[test]
fn bindgen_test_layout_tdTPM_KEY_HANDLE_LIST() {
    assert_eq!(::std::mem::size_of::<tdTPM_KEY_HANDLE_LIST>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_KEY_HANDLE_LIST )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_KEY_HANDLE_LIST>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_KEY_HANDLE_LIST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY_HANDLE_LIST ) ) . loaded as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY_HANDLE_LIST )
                , "::" , stringify ! ( loaded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY_HANDLE_LIST ) ) . handle as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY_HANDLE_LIST )
                , "::" , stringify ! ( handle ) ));
}
impl Clone for tdTPM_KEY_HANDLE_LIST {
    fn clone(&self) -> Self { *self }
}
pub type TPM_KEY_HANDLE_LIST = tdTPM_KEY_HANDLE_LIST;
pub type TPM_KEY_USAGE = UINT16;
pub type TPM_SIG_SCHEME = UINT16;
pub type TPM_ENC_SCHEME = UINT16;
pub type TPM_AUTH_DATA_USAGE = BYTE;
pub type TPM_KEY_FLAGS = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CHANGEAUTH_VALIDATE {
    pub newAuthSecret: TPM_SECRET,
    pub n1: TPM_NONCE,
}
#[test]
fn bindgen_test_layout_tdTPM_CHANGEAUTH_VALIDATE() {
    assert_eq!(::std::mem::size_of::<tdTPM_CHANGEAUTH_VALIDATE>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_CHANGEAUTH_VALIDATE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_CHANGEAUTH_VALIDATE>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_CHANGEAUTH_VALIDATE )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CHANGEAUTH_VALIDATE ) ) .
                newAuthSecret as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_CHANGEAUTH_VALIDATE ) , "::" , stringify ! (
                newAuthSecret ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CHANGEAUTH_VALIDATE ) ) . n1 as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_CHANGEAUTH_VALIDATE ) , "::" , stringify ! ( n1 ) ));
}
impl Clone for tdTPM_CHANGEAUTH_VALIDATE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CHANGEAUTH_VALIDATE = tdTPM_CHANGEAUTH_VALIDATE;
pub type TPM_ACTUAL_COUNT = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_COUNTER_VALUE {
    pub tag: TPM_STRUCTURE_TAG,
    pub label: [BYTE; 4usize],
    pub counter: TPM_ACTUAL_COUNT,
}
#[test]
fn bindgen_test_layout_tdTPM_COUNTER_VALUE() {
    assert_eq!(::std::mem::size_of::<tdTPM_COUNTER_VALUE>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_COUNTER_VALUE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_COUNTER_VALUE>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_COUNTER_VALUE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_COUNTER_VALUE ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_COUNTER_VALUE ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_COUNTER_VALUE ) ) . label as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_COUNTER_VALUE ) ,
                "::" , stringify ! ( label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_COUNTER_VALUE ) ) . counter as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_COUNTER_VALUE ) ,
                "::" , stringify ! ( counter ) ));
}
impl Clone for tdTPM_COUNTER_VALUE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_COUNTER_VALUE = tdTPM_COUNTER_VALUE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_SIGN_INFO {
    pub tag: TPM_STRUCTURE_TAG,
    pub fixed: [BYTE; 4usize],
    pub replay: TPM_NONCE,
    pub dataLen: UINT32,
    pub data: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_SIGN_INFO() {
    assert_eq!(::std::mem::size_of::<tdTPM_SIGN_INFO>() , 40usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_SIGN_INFO ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_SIGN_INFO>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tdTPM_SIGN_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SIGN_INFO ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SIGN_INFO ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SIGN_INFO ) ) . fixed as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SIGN_INFO ) ,
                "::" , stringify ! ( fixed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SIGN_INFO ) ) . replay as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SIGN_INFO ) ,
                "::" , stringify ! ( replay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SIGN_INFO ) ) . dataLen as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SIGN_INFO ) ,
                "::" , stringify ! ( dataLen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SIGN_INFO ) ) . data as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SIGN_INFO ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for tdTPM_SIGN_INFO {
    fn clone(&self) -> Self { *self }
}
pub type TPM_SIGN_INFO = tdTPM_SIGN_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_MSA_COMPOSITE {
    pub MSAlist: UINT32,
    pub migAuthDigest: *mut TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_MSA_COMPOSITE() {
    assert_eq!(::std::mem::size_of::<tdTPM_MSA_COMPOSITE>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_MSA_COMPOSITE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_MSA_COMPOSITE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_MSA_COMPOSITE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MSA_COMPOSITE ) ) . MSAlist as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MSA_COMPOSITE ) ,
                "::" , stringify ! ( MSAlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MSA_COMPOSITE ) ) . migAuthDigest
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MSA_COMPOSITE ) ,
                "::" , stringify ! ( migAuthDigest ) ));
}
impl Clone for tdTPM_MSA_COMPOSITE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_MSA_COMPOSITE = tdTPM_MSA_COMPOSITE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CMK_AUTH {
    pub migrationAuthorityDigest: TPM_DIGEST,
    pub destinationKeyDigest: TPM_DIGEST,
    pub sourceKeyDigest: TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_CMK_AUTH() {
    assert_eq!(::std::mem::size_of::<tdTPM_CMK_AUTH>() , 60usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_CMK_AUTH ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_CMK_AUTH>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_CMK_AUTH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_AUTH ) ) .
                migrationAuthorityDigest as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_AUTH ) , "::"
                , stringify ! ( migrationAuthorityDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_AUTH ) ) . destinationKeyDigest
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_AUTH ) , "::"
                , stringify ! ( destinationKeyDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_AUTH ) ) . sourceKeyDigest as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_AUTH ) , "::"
                , stringify ! ( sourceKeyDigest ) ));
}
impl Clone for tdTPM_CMK_AUTH {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CMK_AUTH = tdTPM_CMK_AUTH;
pub type TPM_CMK_DELEGATE = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_SELECT_SIZE {
    pub major: BYTE,
    pub minor: BYTE,
    pub reqSize: UINT16,
}
#[test]
fn bindgen_test_layout_tdTPM_SELECT_SIZE() {
    assert_eq!(::std::mem::size_of::<tdTPM_SELECT_SIZE>() , 4usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_SELECT_SIZE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_SELECT_SIZE>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_SELECT_SIZE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SELECT_SIZE ) ) . major as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SELECT_SIZE ) ,
                "::" , stringify ! ( major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SELECT_SIZE ) ) . minor as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SELECT_SIZE ) ,
                "::" , stringify ! ( minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SELECT_SIZE ) ) . reqSize as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SELECT_SIZE ) ,
                "::" , stringify ! ( reqSize ) ));
}
impl Clone for tdTPM_SELECT_SIZE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_SELECT_SIZE = tdTPM_SELECT_SIZE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CMK_MIGAUTH {
    pub tag: TPM_STRUCTURE_TAG,
    pub msaDigest: TPM_DIGEST,
    pub pubKeyDigest: TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_CMK_MIGAUTH() {
    assert_eq!(::std::mem::size_of::<tdTPM_CMK_MIGAUTH>() , 42usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_CMK_MIGAUTH ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_CMK_MIGAUTH>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_CMK_MIGAUTH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_MIGAUTH ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_MIGAUTH ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_MIGAUTH ) ) . msaDigest as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_MIGAUTH ) ,
                "::" , stringify ! ( msaDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_MIGAUTH ) ) . pubKeyDigest as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_MIGAUTH ) ,
                "::" , stringify ! ( pubKeyDigest ) ));
}
impl Clone for tdTPM_CMK_MIGAUTH {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CMK_MIGAUTH = tdTPM_CMK_MIGAUTH;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CMK_SIGTICKET {
    pub tag: TPM_STRUCTURE_TAG,
    pub verKeyDigest: TPM_DIGEST,
    pub signedData: TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_CMK_SIGTICKET() {
    assert_eq!(::std::mem::size_of::<tdTPM_CMK_SIGTICKET>() , 42usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_CMK_SIGTICKET ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_CMK_SIGTICKET>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_CMK_SIGTICKET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_SIGTICKET ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_SIGTICKET ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_SIGTICKET ) ) . verKeyDigest as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_SIGTICKET ) ,
                "::" , stringify ! ( verKeyDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_SIGTICKET ) ) . signedData as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_SIGTICKET ) ,
                "::" , stringify ! ( signedData ) ));
}
impl Clone for tdTPM_CMK_SIGTICKET {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CMK_SIGTICKET = tdTPM_CMK_SIGTICKET;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CMK_MA_APPROVAL {
    pub tag: TPM_STRUCTURE_TAG,
    pub migrationAuthorityDigest: TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_CMK_MA_APPROVAL() {
    assert_eq!(::std::mem::size_of::<tdTPM_CMK_MA_APPROVAL>() , 22usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_CMK_MA_APPROVAL )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_CMK_MA_APPROVAL>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_CMK_MA_APPROVAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_MA_APPROVAL ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_MA_APPROVAL )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CMK_MA_APPROVAL ) ) .
                migrationAuthorityDigest as * const _ as usize } , 2usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CMK_MA_APPROVAL )
                , "::" , stringify ! ( migrationAuthorityDigest ) ));
}
impl Clone for tdTPM_CMK_MA_APPROVAL {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CMK_MA_APPROVAL = tdTPM_CMK_MA_APPROVAL;
pub type TPM_TAG = UINT16;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_PERMANENT_FLAGS {
    pub tag: TPM_STRUCTURE_TAG,
    pub disable: TSS_BOOL,
    pub ownership: TSS_BOOL,
    pub deactivated: TSS_BOOL,
    pub readPubek: TSS_BOOL,
    pub disableOwnerClear: TSS_BOOL,
    pub allowMaintenance: TSS_BOOL,
    pub physicalPresenceLifetimeLock: TSS_BOOL,
    pub physicalPresenceHWEnable: TSS_BOOL,
    pub physicalPresenceCMDEnable: TSS_BOOL,
    pub CEKPUsed: TSS_BOOL,
    pub TPMpost: TSS_BOOL,
    pub TPMpostLock: TSS_BOOL,
    pub FIPS: TSS_BOOL,
    pub Operator: TSS_BOOL,
    pub enableRevokeEK: TSS_BOOL,
    pub nvLocked: TSS_BOOL,
    pub readSRKPub: TSS_BOOL,
    pub tpmEstablished: TSS_BOOL,
    pub maintenanceDone: TSS_BOOL,
    pub disableFullDALogicInfo: TSS_BOOL,
}
#[test]
fn bindgen_test_layout_tdTPM_PERMANENT_FLAGS() {
    assert_eq!(::std::mem::size_of::<tdTPM_PERMANENT_FLAGS>() , 22usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_PERMANENT_FLAGS>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_PERMANENT_FLAGS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . disable as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . ownership as
                * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( ownership ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . deactivated
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( deactivated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . readPubek as
                * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( readPubek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) .
                disableOwnerClear as * const _ as usize } , 6usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( disableOwnerClear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) .
                allowMaintenance as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( allowMaintenance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) .
                physicalPresenceLifetimeLock as * const _ as usize } , 8usize
                , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( physicalPresenceLifetimeLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) .
                physicalPresenceHWEnable as * const _ as usize } , 9usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( physicalPresenceHWEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) .
                physicalPresenceCMDEnable as * const _ as usize } , 10usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( physicalPresenceCMDEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . CEKPUsed as *
                const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( CEKPUsed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . TPMpost as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( TPMpost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . TPMpostLock
                as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( TPMpostLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . FIPS as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( FIPS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . Operator as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( Operator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) .
                enableRevokeEK as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( enableRevokeEK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . nvLocked as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( nvLocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) . readSRKPub as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( readSRKPub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) .
                tpmEstablished as * const _ as usize } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( tpmEstablished ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) .
                maintenanceDone as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( maintenanceDone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PERMANENT_FLAGS ) ) .
                disableFullDALogicInfo as * const _ as usize } , 21usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PERMANENT_FLAGS )
                , "::" , stringify ! ( disableFullDALogicInfo ) ));
}
impl Clone for tdTPM_PERMANENT_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_PERMANENT_FLAGS = tdTPM_PERMANENT_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_STCLEAR_FLAGS {
    pub tag: TPM_STRUCTURE_TAG,
    pub deactivated: TSS_BOOL,
    pub disableForceClear: TSS_BOOL,
    pub physicalPresence: TSS_BOOL,
    pub physicalPresenceLock: TSS_BOOL,
    pub bGlobalLock: TSS_BOOL,
}
#[test]
fn bindgen_test_layout_tdTPM_STCLEAR_FLAGS() {
    assert_eq!(::std::mem::size_of::<tdTPM_STCLEAR_FLAGS>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_STCLEAR_FLAGS ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_STCLEAR_FLAGS>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_STCLEAR_FLAGS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STCLEAR_FLAGS ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STCLEAR_FLAGS ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STCLEAR_FLAGS ) ) . deactivated as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STCLEAR_FLAGS ) ,
                "::" , stringify ! ( deactivated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STCLEAR_FLAGS ) ) .
                disableForceClear as * const _ as usize } , 3usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_STCLEAR_FLAGS ) ,
                "::" , stringify ! ( disableForceClear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STCLEAR_FLAGS ) ) .
                physicalPresence as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STCLEAR_FLAGS ) ,
                "::" , stringify ! ( physicalPresence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STCLEAR_FLAGS ) ) .
                physicalPresenceLock as * const _ as usize } , 5usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTPM_STCLEAR_FLAGS ) ,
                "::" , stringify ! ( physicalPresenceLock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STCLEAR_FLAGS ) ) . bGlobalLock as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STCLEAR_FLAGS ) ,
                "::" , stringify ! ( bGlobalLock ) ));
}
impl Clone for tdTPM_STCLEAR_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_STCLEAR_FLAGS = tdTPM_STCLEAR_FLAGS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_STANY_FLAGS {
    pub tag: TPM_STRUCTURE_TAG,
    pub postInitialise: TSS_BOOL,
    pub localityModifier: TPM_MODIFIER_INDICATOR,
    pub transportExclusive: TSS_BOOL,
    pub TOSPresent: TSS_BOOL,
}
#[test]
fn bindgen_test_layout_tdTPM_STANY_FLAGS() {
    assert_eq!(::std::mem::size_of::<tdTPM_STANY_FLAGS>() , 12usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_STANY_FLAGS ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_STANY_FLAGS>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_STANY_FLAGS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STANY_FLAGS ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STANY_FLAGS ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STANY_FLAGS ) ) . postInitialise as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STANY_FLAGS ) ,
                "::" , stringify ! ( postInitialise ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STANY_FLAGS ) ) . localityModifier
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STANY_FLAGS ) ,
                "::" , stringify ! ( localityModifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STANY_FLAGS ) ) .
                transportExclusive as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_STANY_FLAGS ) ,
                "::" , stringify ! ( transportExclusive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STANY_FLAGS ) ) . TOSPresent as *
                const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STANY_FLAGS ) ,
                "::" , stringify ! ( TOSPresent ) ));
}
impl Clone for tdTPM_STANY_FLAGS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_STANY_FLAGS = tdTPM_STANY_FLAGS;
pub type TPM_LOCALITY_SELECTION = BYTE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_PCR_SELECTION {
    pub sizeOfSelect: UINT16,
    pub pcrSelect: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_PCR_SELECTION() {
    assert_eq!(::std::mem::size_of::<tdTPM_PCR_SELECTION>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_PCR_SELECTION ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_PCR_SELECTION>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_PCR_SELECTION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_SELECTION ) ) . sizeOfSelect as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_SELECTION ) ,
                "::" , stringify ! ( sizeOfSelect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_SELECTION ) ) . pcrSelect as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_SELECTION ) ,
                "::" , stringify ! ( pcrSelect ) ));
}
impl Clone for tdTPM_PCR_SELECTION {
    fn clone(&self) -> Self { *self }
}
pub type TPM_PCR_SELECTION = tdTPM_PCR_SELECTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_PCR_COMPOSITE {
    pub select: TPM_PCR_SELECTION,
    pub valueSize: UINT32,
    pub pcrValue: *mut TPM_PCRVALUE,
}
#[test]
fn bindgen_test_layout_tdTPM_PCR_COMPOSITE() {
    assert_eq!(::std::mem::size_of::<tdTPM_PCR_COMPOSITE>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_PCR_COMPOSITE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_PCR_COMPOSITE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_PCR_COMPOSITE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_COMPOSITE ) ) . select as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_COMPOSITE ) ,
                "::" , stringify ! ( select ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_COMPOSITE ) ) . valueSize as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_COMPOSITE ) ,
                "::" , stringify ! ( valueSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_COMPOSITE ) ) . pcrValue as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_COMPOSITE ) ,
                "::" , stringify ! ( pcrValue ) ));
}
impl Clone for tdTPM_PCR_COMPOSITE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_PCR_COMPOSITE = tdTPM_PCR_COMPOSITE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_PCR_INFO {
    pub pcrSelection: TPM_PCR_SELECTION,
    pub digestAtRelease: TPM_COMPOSITE_HASH,
    pub digestAtCreation: TPM_COMPOSITE_HASH,
}
#[test]
fn bindgen_test_layout_tdTPM_PCR_INFO() {
    assert_eq!(::std::mem::size_of::<tdTPM_PCR_INFO>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_PCR_INFO ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_PCR_INFO>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_PCR_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO ) ) . pcrSelection as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO ) , "::"
                , stringify ! ( pcrSelection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO ) ) . digestAtRelease as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO ) , "::"
                , stringify ! ( digestAtRelease ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO ) ) . digestAtCreation as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO ) , "::"
                , stringify ! ( digestAtCreation ) ));
}
impl Clone for tdTPM_PCR_INFO {
    fn clone(&self) -> Self { *self }
}
pub type TPM_PCR_INFO = tdTPM_PCR_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_PCR_INFO_LONG {
    pub tag: TPM_STRUCTURE_TAG,
    pub localityAtCreation: TPM_LOCALITY_SELECTION,
    pub localityAtRelease: TPM_LOCALITY_SELECTION,
    pub creationPCRSelection: TPM_PCR_SELECTION,
    pub releasePCRSelection: TPM_PCR_SELECTION,
    pub digestAtCreation: TPM_COMPOSITE_HASH,
    pub digestAtRelease: TPM_COMPOSITE_HASH,
}
#[test]
fn bindgen_test_layout_tdTPM_PCR_INFO_LONG() {
    assert_eq!(::std::mem::size_of::<tdTPM_PCR_INFO_LONG>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_PCR_INFO_LONG ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_PCR_INFO_LONG>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_PCR_INFO_LONG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_LONG ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_LONG ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_LONG ) ) .
                localityAtCreation as * const _ as usize } , 2usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_LONG ) ,
                "::" , stringify ! ( localityAtCreation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_LONG ) ) .
                localityAtRelease as * const _ as usize } , 3usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_LONG ) ,
                "::" , stringify ! ( localityAtRelease ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_LONG ) ) .
                creationPCRSelection as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_LONG ) ,
                "::" , stringify ! ( creationPCRSelection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_LONG ) ) .
                releasePCRSelection as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_LONG ) ,
                "::" , stringify ! ( releasePCRSelection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_LONG ) ) .
                digestAtCreation as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_LONG ) ,
                "::" , stringify ! ( digestAtCreation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_LONG ) ) . digestAtRelease
                as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_LONG ) ,
                "::" , stringify ! ( digestAtRelease ) ));
}
impl Clone for tdTPM_PCR_INFO_LONG {
    fn clone(&self) -> Self { *self }
}
pub type TPM_PCR_INFO_LONG = tdTPM_PCR_INFO_LONG;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_PCR_INFO_SHORT {
    pub pcrSelection: TPM_PCR_SELECTION,
    pub localityAtRelease: TPM_LOCALITY_SELECTION,
    pub digestAtRelease: TPM_COMPOSITE_HASH,
}
#[test]
fn bindgen_test_layout_tdTPM_PCR_INFO_SHORT() {
    assert_eq!(::std::mem::size_of::<tdTPM_PCR_INFO_SHORT>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_PCR_INFO_SHORT )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_PCR_INFO_SHORT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_PCR_INFO_SHORT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_SHORT ) ) . pcrSelection
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_SHORT )
                , "::" , stringify ! ( pcrSelection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_SHORT ) ) .
                localityAtRelease as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_SHORT )
                , "::" , stringify ! ( localityAtRelease ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_INFO_SHORT ) ) .
                digestAtRelease as * const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_INFO_SHORT )
                , "::" , stringify ! ( digestAtRelease ) ));
}
impl Clone for tdTPM_PCR_INFO_SHORT {
    fn clone(&self) -> Self { *self }
}
pub type TPM_PCR_INFO_SHORT = tdTPM_PCR_INFO_SHORT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_PCR_ATTRIBUTES {
    pub pcrReset: BYTE,
    pub pcrExtendLocal: TPM_LOCALITY_SELECTION,
    pub pcrResetLocal: TPM_LOCALITY_SELECTION,
}
#[test]
fn bindgen_test_layout_tdTPM_PCR_ATTRIBUTES() {
    assert_eq!(::std::mem::size_of::<tdTPM_PCR_ATTRIBUTES>() , 3usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_PCR_ATTRIBUTES ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_PCR_ATTRIBUTES>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_PCR_ATTRIBUTES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_ATTRIBUTES ) ) . pcrReset as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_ATTRIBUTES )
                , "::" , stringify ! ( pcrReset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_ATTRIBUTES ) ) . pcrExtendLocal
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_ATTRIBUTES )
                , "::" , stringify ! ( pcrExtendLocal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PCR_ATTRIBUTES ) ) . pcrResetLocal
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PCR_ATTRIBUTES )
                , "::" , stringify ! ( pcrResetLocal ) ));
}
impl Clone for tdTPM_PCR_ATTRIBUTES {
    fn clone(&self) -> Self { *self }
}
pub type TPM_PCR_ATTRIBUTES = tdTPM_PCR_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_STORED_DATA {
    pub ver: TPM_STRUCT_VER,
    pub sealInfoSize: UINT32,
    pub sealInfo: *mut BYTE,
    pub encDataSize: UINT32,
    pub encData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_STORED_DATA() {
    assert_eq!(::std::mem::size_of::<tdTPM_STORED_DATA>() , 32usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_STORED_DATA ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_STORED_DATA>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_STORED_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA ) ) . ver as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA ) ,
                "::" , stringify ! ( ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA ) ) . sealInfoSize as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA ) ,
                "::" , stringify ! ( sealInfoSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA ) ) . sealInfo as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA ) ,
                "::" , stringify ! ( sealInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA ) ) . encDataSize as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA ) ,
                "::" , stringify ! ( encDataSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA ) ) . encData as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA ) ,
                "::" , stringify ! ( encData ) ));
}
impl Clone for tdTPM_STORED_DATA {
    fn clone(&self) -> Self { *self }
}
pub type TPM_STORED_DATA = tdTPM_STORED_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_STORED_DATA12 {
    pub tag: TPM_STRUCTURE_TAG,
    pub et: TPM_ENTITY_TYPE,
    pub sealInfoSize: UINT32,
    pub sealInfo: *mut BYTE,
    pub encDataSize: UINT32,
    pub encData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_STORED_DATA12() {
    assert_eq!(::std::mem::size_of::<tdTPM_STORED_DATA12>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_STORED_DATA12 ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_STORED_DATA12>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_STORED_DATA12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA12 ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA12 ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA12 ) ) . et as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA12 ) ,
                "::" , stringify ! ( et ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA12 ) ) . sealInfoSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA12 ) ,
                "::" , stringify ! ( sealInfoSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA12 ) ) . sealInfo as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA12 ) ,
                "::" , stringify ! ( sealInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA12 ) ) . encDataSize as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA12 ) ,
                "::" , stringify ! ( encDataSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORED_DATA12 ) ) . encData as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORED_DATA12 ) ,
                "::" , stringify ! ( encData ) ));
}
impl Clone for tdTPM_STORED_DATA12 {
    fn clone(&self) -> Self { *self }
}
pub type TPM_STORED_DATA12 = tdTPM_STORED_DATA12;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_SEALED_DATA {
    pub payload: TPM_PAYLOAD_TYPE,
    pub authData: TPM_SECRET,
    pub tpmProof: TPM_NONCE,
    pub storedDigest: TPM_DIGEST,
    pub dataSize: UINT32,
    pub data: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_SEALED_DATA() {
    assert_eq!(::std::mem::size_of::<tdTPM_SEALED_DATA>() , 80usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_SEALED_DATA ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_SEALED_DATA>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_SEALED_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SEALED_DATA ) ) . payload as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SEALED_DATA ) ,
                "::" , stringify ! ( payload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SEALED_DATA ) ) . authData as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SEALED_DATA ) ,
                "::" , stringify ! ( authData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SEALED_DATA ) ) . tpmProof as *
                const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SEALED_DATA ) ,
                "::" , stringify ! ( tpmProof ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SEALED_DATA ) ) . storedDigest as *
                const _ as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SEALED_DATA ) ,
                "::" , stringify ! ( storedDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SEALED_DATA ) ) . dataSize as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SEALED_DATA ) ,
                "::" , stringify ! ( dataSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SEALED_DATA ) ) . data as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SEALED_DATA ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for tdTPM_SEALED_DATA {
    fn clone(&self) -> Self { *self }
}
pub type TPM_SEALED_DATA = tdTPM_SEALED_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_SYMMETRIC_KEY {
    pub algId: TPM_ALGORITHM_ID,
    pub encScheme: TPM_ENC_SCHEME,
    pub size: UINT16,
    pub data: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_SYMMETRIC_KEY() {
    assert_eq!(::std::mem::size_of::<tdTPM_SYMMETRIC_KEY>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_SYMMETRIC_KEY ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_SYMMETRIC_KEY>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_SYMMETRIC_KEY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYMMETRIC_KEY ) ) . algId as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SYMMETRIC_KEY ) ,
                "::" , stringify ! ( algId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYMMETRIC_KEY ) ) . encScheme as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SYMMETRIC_KEY ) ,
                "::" , stringify ! ( encScheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYMMETRIC_KEY ) ) . size as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SYMMETRIC_KEY ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYMMETRIC_KEY ) ) . data as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_SYMMETRIC_KEY ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for tdTPM_SYMMETRIC_KEY {
    fn clone(&self) -> Self { *self }
}
pub type TPM_SYMMETRIC_KEY = tdTPM_SYMMETRIC_KEY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_BOUND_DATA {
    pub ver: TPM_STRUCT_VER,
    pub payload: TPM_PAYLOAD_TYPE,
    pub payloadData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_BOUND_DATA() {
    assert_eq!(::std::mem::size_of::<tdTPM_BOUND_DATA>() , 16usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_BOUND_DATA ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_BOUND_DATA>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tdTPM_BOUND_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_BOUND_DATA ) ) . ver as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_BOUND_DATA ) ,
                "::" , stringify ! ( ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_BOUND_DATA ) ) . payload as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_BOUND_DATA ) ,
                "::" , stringify ! ( payload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_BOUND_DATA ) ) . payloadData as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_BOUND_DATA ) ,
                "::" , stringify ! ( payloadData ) ));
}
impl Clone for tdTPM_BOUND_DATA {
    fn clone(&self) -> Self { *self }
}
pub type TPM_BOUND_DATA = tdTPM_BOUND_DATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_KEY_PARMS {
    pub algorithmID: TPM_ALGORITHM_ID,
    pub encScheme: TPM_ENC_SCHEME,
    pub sigScheme: TPM_SIG_SCHEME,
    pub parmSize: UINT32,
    pub parms: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_KEY_PARMS() {
    assert_eq!(::std::mem::size_of::<tdTPM_KEY_PARMS>() , 24usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_KEY_PARMS ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_KEY_PARMS>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tdTPM_KEY_PARMS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY_PARMS ) ) . algorithmID as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY_PARMS ) ,
                "::" , stringify ! ( algorithmID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY_PARMS ) ) . encScheme as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY_PARMS ) ,
                "::" , stringify ! ( encScheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY_PARMS ) ) . sigScheme as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY_PARMS ) ,
                "::" , stringify ! ( sigScheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY_PARMS ) ) . parmSize as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY_PARMS ) ,
                "::" , stringify ! ( parmSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY_PARMS ) ) . parms as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY_PARMS ) ,
                "::" , stringify ! ( parms ) ));
}
impl Clone for tdTPM_KEY_PARMS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_KEY_PARMS = tdTPM_KEY_PARMS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_RSA_KEY_PARMS {
    pub keyLength: UINT32,
    pub numPrimes: UINT32,
    pub exponentSize: UINT32,
    pub exponent: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_RSA_KEY_PARMS() {
    assert_eq!(::std::mem::size_of::<tdTPM_RSA_KEY_PARMS>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_RSA_KEY_PARMS ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_RSA_KEY_PARMS>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_RSA_KEY_PARMS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_RSA_KEY_PARMS ) ) . keyLength as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_RSA_KEY_PARMS ) ,
                "::" , stringify ! ( keyLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_RSA_KEY_PARMS ) ) . numPrimes as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_RSA_KEY_PARMS ) ,
                "::" , stringify ! ( numPrimes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_RSA_KEY_PARMS ) ) . exponentSize as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_RSA_KEY_PARMS ) ,
                "::" , stringify ! ( exponentSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_RSA_KEY_PARMS ) ) . exponent as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_RSA_KEY_PARMS ) ,
                "::" , stringify ! ( exponent ) ));
}
impl Clone for tdTPM_RSA_KEY_PARMS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_RSA_KEY_PARMS = tdTPM_RSA_KEY_PARMS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_SYMMETRIC_KEY_PARMS {
    pub keyLength: UINT32,
    pub blockSize: UINT32,
    pub ivSize: UINT32,
    pub IV: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_SYMMETRIC_KEY_PARMS() {
    assert_eq!(::std::mem::size_of::<tdTPM_SYMMETRIC_KEY_PARMS>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_SYMMETRIC_KEY_PARMS ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_SYMMETRIC_KEY_PARMS>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_SYMMETRIC_KEY_PARMS )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYMMETRIC_KEY_PARMS ) ) . keyLength
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_SYMMETRIC_KEY_PARMS ) , "::" , stringify ! ( keyLength )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYMMETRIC_KEY_PARMS ) ) . blockSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_SYMMETRIC_KEY_PARMS ) , "::" , stringify ! ( blockSize )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYMMETRIC_KEY_PARMS ) ) . ivSize as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_SYMMETRIC_KEY_PARMS ) , "::" , stringify ! ( ivSize )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYMMETRIC_KEY_PARMS ) ) . IV as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_SYMMETRIC_KEY_PARMS ) , "::" , stringify ! ( IV ) ));
}
impl Clone for tdTPM_SYMMETRIC_KEY_PARMS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_SYMMETRIC_KEY_PARMS = tdTPM_SYMMETRIC_KEY_PARMS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_STORE_PUBKEY {
    pub keyLength: UINT32,
    pub key: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_STORE_PUBKEY() {
    assert_eq!(::std::mem::size_of::<tdTPM_STORE_PUBKEY>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_STORE_PUBKEY ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_STORE_PUBKEY>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_STORE_PUBKEY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORE_PUBKEY ) ) . keyLength as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORE_PUBKEY ) ,
                "::" , stringify ! ( keyLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORE_PUBKEY ) ) . key as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORE_PUBKEY ) ,
                "::" , stringify ! ( key ) ));
}
impl Clone for tdTPM_STORE_PUBKEY {
    fn clone(&self) -> Self { *self }
}
pub type TPM_STORE_PUBKEY = tdTPM_STORE_PUBKEY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_PUBKEY {
    pub algorithmParms: TPM_KEY_PARMS,
    pub pubKey: TPM_STORE_PUBKEY,
}
#[test]
fn bindgen_test_layout_tdTPM_PUBKEY() {
    assert_eq!(::std::mem::size_of::<tdTPM_PUBKEY>() , 40usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_PUBKEY ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_PUBKEY>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_PUBKEY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PUBKEY ) ) . algorithmParms as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PUBKEY ) , "::" ,
                stringify ! ( algorithmParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_PUBKEY ) ) . pubKey as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_PUBKEY ) , "::" ,
                stringify ! ( pubKey ) ));
}
impl Clone for tdTPM_PUBKEY {
    fn clone(&self) -> Self { *self }
}
pub type TPM_PUBKEY = tdTPM_PUBKEY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_STORE_PRIVKEY {
    pub keyLength: UINT32,
    pub key: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_STORE_PRIVKEY() {
    assert_eq!(::std::mem::size_of::<tdTPM_STORE_PRIVKEY>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_STORE_PRIVKEY ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_STORE_PRIVKEY>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_STORE_PRIVKEY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORE_PRIVKEY ) ) . keyLength as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORE_PRIVKEY ) ,
                "::" , stringify ! ( keyLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORE_PRIVKEY ) ) . key as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORE_PRIVKEY ) ,
                "::" , stringify ! ( key ) ));
}
impl Clone for tdTPM_STORE_PRIVKEY {
    fn clone(&self) -> Self { *self }
}
pub type TPM_STORE_PRIVKEY = tdTPM_STORE_PRIVKEY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_STORE_ASYMKEY {
    pub payload: TPM_PAYLOAD_TYPE,
    pub usageAuth: TPM_SECRET,
    pub migrationAuth: TPM_SECRET,
    pub pubDataDigest: TPM_DIGEST,
    pub privKey: TPM_STORE_PRIVKEY,
}
#[test]
fn bindgen_test_layout_tdTPM_STORE_ASYMKEY() {
    assert_eq!(::std::mem::size_of::<tdTPM_STORE_ASYMKEY>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_STORE_ASYMKEY ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_STORE_ASYMKEY>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_STORE_ASYMKEY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORE_ASYMKEY ) ) . payload as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORE_ASYMKEY ) ,
                "::" , stringify ! ( payload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORE_ASYMKEY ) ) . usageAuth as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORE_ASYMKEY ) ,
                "::" , stringify ! ( usageAuth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORE_ASYMKEY ) ) . migrationAuth
                as * const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORE_ASYMKEY ) ,
                "::" , stringify ! ( migrationAuth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORE_ASYMKEY ) ) . pubDataDigest
                as * const _ as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORE_ASYMKEY ) ,
                "::" , stringify ! ( pubDataDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_STORE_ASYMKEY ) ) . privKey as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_STORE_ASYMKEY ) ,
                "::" , stringify ! ( privKey ) ));
}
impl Clone for tdTPM_STORE_ASYMKEY {
    fn clone(&self) -> Self { *self }
}
pub type TPM_STORE_ASYMKEY = tdTPM_STORE_ASYMKEY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_KEY {
    pub ver: TPM_STRUCT_VER,
    pub keyUsage: TPM_KEY_USAGE,
    pub keyFlags: TPM_KEY_FLAGS,
    pub authDataUsage: TPM_AUTH_DATA_USAGE,
    pub algorithmParms: TPM_KEY_PARMS,
    pub PCRInfoSize: UINT32,
    pub PCRInfo: *mut BYTE,
    pub pubKey: TPM_STORE_PUBKEY,
    pub encSize: UINT32,
    pub encData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_KEY() {
    assert_eq!(::std::mem::size_of::<tdTPM_KEY>() , 88usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_KEY ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_KEY>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_KEY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . ver as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . keyUsage as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( keyUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . keyFlags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( keyFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . authDataUsage as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( authDataUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . algorithmParms as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( algorithmParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . PCRInfoSize as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( PCRInfoSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . PCRInfo as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( PCRInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . pubKey as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( pubKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . encSize as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( encSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY ) ) . encData as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY ) , "::" ,
                stringify ! ( encData ) ));
}
impl Clone for tdTPM_KEY {
    fn clone(&self) -> Self { *self }
}
pub type TPM_KEY = tdTPM_KEY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_KEY12 {
    pub tag: TPM_STRUCTURE_TAG,
    pub fill: UINT16,
    pub keyUsage: TPM_KEY_USAGE,
    pub keyFlags: TPM_KEY_FLAGS,
    pub authDataUsage: TPM_AUTH_DATA_USAGE,
    pub algorithmParms: TPM_KEY_PARMS,
    pub PCRInfoSize: UINT32,
    pub PCRInfo: *mut BYTE,
    pub pubKey: TPM_STORE_PUBKEY,
    pub encSize: UINT32,
    pub encData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_KEY12() {
    assert_eq!(::std::mem::size_of::<tdTPM_KEY12>() , 88usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_KEY12 ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_KEY12>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_KEY12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . fill as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( fill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . keyUsage as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( keyUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . keyFlags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( keyFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . authDataUsage as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( authDataUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . algorithmParms as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( algorithmParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . PCRInfoSize as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( PCRInfoSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . PCRInfo as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( PCRInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . pubKey as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( pubKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . encSize as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( encSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_KEY12 ) ) . encData as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_KEY12 ) , "::" ,
                stringify ! ( encData ) ));
}
impl Clone for tdTPM_KEY12 {
    fn clone(&self) -> Self { *self }
}
pub type TPM_KEY12 = tdTPM_KEY12;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_MIGRATE_ASYMKEY {
    pub payload: TPM_PAYLOAD_TYPE,
    pub usageAuth: TPM_SECRET,
    pub pubDataDigest: TPM_DIGEST,
    pub partPrivKeyLen: UINT32,
    pub partPrivKey: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_MIGRATE_ASYMKEY() {
    assert_eq!(::std::mem::size_of::<tdTPM_MIGRATE_ASYMKEY>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_MIGRATE_ASYMKEY )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_MIGRATE_ASYMKEY>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_MIGRATE_ASYMKEY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MIGRATE_ASYMKEY ) ) . payload as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MIGRATE_ASYMKEY )
                , "::" , stringify ! ( payload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MIGRATE_ASYMKEY ) ) . usageAuth as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MIGRATE_ASYMKEY )
                , "::" , stringify ! ( usageAuth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MIGRATE_ASYMKEY ) ) . pubDataDigest
                as * const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MIGRATE_ASYMKEY )
                , "::" , stringify ! ( pubDataDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MIGRATE_ASYMKEY ) ) .
                partPrivKeyLen as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MIGRATE_ASYMKEY )
                , "::" , stringify ! ( partPrivKeyLen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MIGRATE_ASYMKEY ) ) . partPrivKey
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MIGRATE_ASYMKEY )
                , "::" , stringify ! ( partPrivKey ) ));
}
impl Clone for tdTPM_MIGRATE_ASYMKEY {
    fn clone(&self) -> Self { *self }
}
pub type TPM_MIGRATE_ASYMKEY = tdTPM_MIGRATE_ASYMKEY;
pub type TPM_KEY_CONTROL = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_MIGRATIONKEYAUTH {
    pub migrationKey: TPM_PUBKEY,
    pub migrationScheme: TPM_MIGRATE_SCHEME,
    pub digest: TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_MIGRATIONKEYAUTH() {
    assert_eq!(::std::mem::size_of::<tdTPM_MIGRATIONKEYAUTH>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_MIGRATIONKEYAUTH )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_MIGRATIONKEYAUTH>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_MIGRATIONKEYAUTH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MIGRATIONKEYAUTH ) ) . migrationKey
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MIGRATIONKEYAUTH
                ) , "::" , stringify ! ( migrationKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MIGRATIONKEYAUTH ) ) .
                migrationScheme as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MIGRATIONKEYAUTH
                ) , "::" , stringify ! ( migrationScheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_MIGRATIONKEYAUTH ) ) . digest as *
                const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_MIGRATIONKEYAUTH
                ) , "::" , stringify ! ( digest ) ));
}
impl Clone for tdTPM_MIGRATIONKEYAUTH {
    fn clone(&self) -> Self { *self }
}
pub type TPM_MIGRATIONKEYAUTH = tdTPM_MIGRATIONKEYAUTH;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CERTIFY_INFO {
    pub version: TPM_STRUCT_VER,
    pub keyUsage: TPM_KEY_USAGE,
    pub keyFlags: TPM_KEY_FLAGS,
    pub authDataUsage: TPM_AUTH_DATA_USAGE,
    pub algorithmParms: TPM_KEY_PARMS,
    pub pubkeyDigest: TPM_DIGEST,
    pub data: TPM_NONCE,
    pub parentPCRStatus: TPM_BOOL,
    pub PCRInfoSize: UINT32,
    pub PCRInfo: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_CERTIFY_INFO() {
    assert_eq!(::std::mem::size_of::<tdTPM_CERTIFY_INFO>() , 96usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_CERTIFY_INFO ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_CERTIFY_INFO>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_CERTIFY_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . keyUsage as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( keyUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . keyFlags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( keyFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . authDataUsage as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( authDataUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . algorithmParms
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( algorithmParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . pubkeyDigest as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( pubkeyDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . data as * const
                _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . parentPCRStatus
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( parentPCRStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . PCRInfoSize as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( PCRInfoSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO ) ) . PCRInfo as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO ) ,
                "::" , stringify ! ( PCRInfo ) ));
}
impl Clone for tdTPM_CERTIFY_INFO {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CERTIFY_INFO = tdTPM_CERTIFY_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CERTIFY_INFO2 {
    pub tag: TPM_STRUCTURE_TAG,
    pub fill: BYTE,
    pub payloadType: TPM_PAYLOAD_TYPE,
    pub keyUsage: TPM_KEY_USAGE,
    pub keyFlags: TPM_KEY_FLAGS,
    pub authDataUsage: TPM_AUTH_DATA_USAGE,
    pub algorithmParms: TPM_KEY_PARMS,
    pub pubkeyDigest: TPM_DIGEST,
    pub data: TPM_NONCE,
    pub parentPCRStatus: TPM_BOOL,
    pub PCRInfoSize: UINT32,
    pub PCRInfo: *mut BYTE,
    pub migrationAuthoritySize: UINT32,
    pub migrationAuthority: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_CERTIFY_INFO2() {
    assert_eq!(::std::mem::size_of::<tdTPM_CERTIFY_INFO2>() , 112usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_CERTIFY_INFO2 )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_CERTIFY_INFO2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . fill as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( fill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . payloadType as
                * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( payloadType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . keyUsage as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( keyUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . keyFlags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( keyFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . authDataUsage
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( authDataUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . algorithmParms
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( algorithmParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . pubkeyDigest as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( pubkeyDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . data as * const
                _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . parentPCRStatus
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( parentPCRStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . PCRInfoSize as
                * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( PCRInfoSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) . PCRInfo as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( PCRInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) .
                migrationAuthoritySize as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( migrationAuthoritySize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CERTIFY_INFO2 ) ) .
                migrationAuthority as * const _ as usize } , 104usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTPM_CERTIFY_INFO2 ) ,
                "::" , stringify ! ( migrationAuthority ) ));
}
impl Clone for tdTPM_CERTIFY_INFO2 {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CERTIFY_INFO2 = tdTPM_CERTIFY_INFO2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_QUOTE_INFO {
    pub version: TPM_STRUCT_VER,
    pub fixed: [BYTE; 4usize],
    pub compositeHash: TPM_COMPOSITE_HASH,
    pub externalData: TPM_NONCE,
}
#[test]
fn bindgen_test_layout_tdTPM_QUOTE_INFO() {
    assert_eq!(::std::mem::size_of::<tdTPM_QUOTE_INFO>() , 48usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_QUOTE_INFO ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_QUOTE_INFO>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( tdTPM_QUOTE_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_QUOTE_INFO ) ) . version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_QUOTE_INFO ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_QUOTE_INFO ) ) . fixed as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_QUOTE_INFO ) ,
                "::" , stringify ! ( fixed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_QUOTE_INFO ) ) . compositeHash as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_QUOTE_INFO ) ,
                "::" , stringify ! ( compositeHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_QUOTE_INFO ) ) . externalData as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_QUOTE_INFO ) ,
                "::" , stringify ! ( externalData ) ));
}
impl Clone for tdTPM_QUOTE_INFO {
    fn clone(&self) -> Self { *self }
}
pub type TPM_QUOTE_INFO = tdTPM_QUOTE_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_QUOTE_INFO2 {
    pub tag: TPM_STRUCTURE_TAG,
    pub fixed: [BYTE; 4usize],
    pub externalData: TPM_NONCE,
    pub infoShort: TPM_PCR_INFO_SHORT,
}
#[test]
fn bindgen_test_layout_tdTPM_QUOTE_INFO2() {
    assert_eq!(::std::mem::size_of::<tdTPM_QUOTE_INFO2>() , 72usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_QUOTE_INFO2 ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_QUOTE_INFO2>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_QUOTE_INFO2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_QUOTE_INFO2 ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_QUOTE_INFO2 ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_QUOTE_INFO2 ) ) . fixed as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_QUOTE_INFO2 ) ,
                "::" , stringify ! ( fixed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_QUOTE_INFO2 ) ) . externalData as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_QUOTE_INFO2 ) ,
                "::" , stringify ! ( externalData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_QUOTE_INFO2 ) ) . infoShort as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_QUOTE_INFO2 ) ,
                "::" , stringify ! ( infoShort ) ));
}
impl Clone for tdTPM_QUOTE_INFO2 {
    fn clone(&self) -> Self { *self }
}
pub type TPM_QUOTE_INFO2 = tdTPM_QUOTE_INFO2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_EK_BLOB {
    pub tag: TPM_STRUCTURE_TAG,
    pub ekType: TPM_EK_TYPE,
    pub blobSize: UINT32,
    pub blob: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_EK_BLOB() {
    assert_eq!(::std::mem::size_of::<tdTPM_EK_BLOB>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_EK_BLOB ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_EK_BLOB>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_EK_BLOB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB ) , "::"
                , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB ) ) . ekType as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB ) , "::"
                , stringify ! ( ekType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB ) ) . blobSize as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB ) , "::"
                , stringify ! ( blobSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB ) ) . blob as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB ) , "::"
                , stringify ! ( blob ) ));
}
impl Clone for tdTPM_EK_BLOB {
    fn clone(&self) -> Self { *self }
}
pub type TPM_EK_BLOB = tdTPM_EK_BLOB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_EK_BLOB_ACTIVATE {
    pub tag: TPM_STRUCTURE_TAG,
    pub sessionKey: TPM_SYMMETRIC_KEY,
    pub idDigest: TPM_DIGEST,
    pub pcrInfo: TPM_PCR_INFO_SHORT,
}
#[test]
fn bindgen_test_layout_tdTPM_EK_BLOB_ACTIVATE() {
    assert_eq!(::std::mem::size_of::<tdTPM_EK_BLOB_ACTIVATE>() , 88usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_EK_BLOB_ACTIVATE )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_EK_BLOB_ACTIVATE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_EK_BLOB_ACTIVATE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB_ACTIVATE ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB_ACTIVATE
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB_ACTIVATE ) ) . sessionKey
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB_ACTIVATE
                ) , "::" , stringify ! ( sessionKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB_ACTIVATE ) ) . idDigest as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB_ACTIVATE
                ) , "::" , stringify ! ( idDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB_ACTIVATE ) ) . pcrInfo as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB_ACTIVATE
                ) , "::" , stringify ! ( pcrInfo ) ));
}
impl Clone for tdTPM_EK_BLOB_ACTIVATE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_EK_BLOB_ACTIVATE = tdTPM_EK_BLOB_ACTIVATE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_EK_BLOB_AUTH {
    pub tag: TPM_STRUCTURE_TAG,
    pub authValue: TPM_SECRET,
}
#[test]
fn bindgen_test_layout_tdTPM_EK_BLOB_AUTH() {
    assert_eq!(::std::mem::size_of::<tdTPM_EK_BLOB_AUTH>() , 22usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_EK_BLOB_AUTH ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_EK_BLOB_AUTH>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_EK_BLOB_AUTH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB_AUTH ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB_AUTH ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_EK_BLOB_AUTH ) ) . authValue as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_EK_BLOB_AUTH ) ,
                "::" , stringify ! ( authValue ) ));
}
impl Clone for tdTPM_EK_BLOB_AUTH {
    fn clone(&self) -> Self { *self }
}
pub type TPM_EK_BLOB_AUTH = tdTPM_EK_BLOB_AUTH;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_IDENTITY_CONTENTS {
    pub ver: TPM_STRUCT_VER,
    pub ordinal: UINT32,
    pub labelPrivCADigest: TPM_CHOSENID_HASH,
    pub identityPubKey: TPM_PUBKEY,
}
#[test]
fn bindgen_test_layout_tdTPM_IDENTITY_CONTENTS() {
    assert_eq!(::std::mem::size_of::<tdTPM_IDENTITY_CONTENTS>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_IDENTITY_CONTENTS ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_IDENTITY_CONTENTS>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_IDENTITY_CONTENTS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_CONTENTS ) ) . ver as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_CONTENTS
                ) , "::" , stringify ! ( ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_CONTENTS ) ) . ordinal as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_CONTENTS
                ) , "::" , stringify ! ( ordinal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_CONTENTS ) ) .
                labelPrivCADigest as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_CONTENTS
                ) , "::" , stringify ! ( labelPrivCADigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_CONTENTS ) ) .
                identityPubKey as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_CONTENTS
                ) , "::" , stringify ! ( identityPubKey ) ));
}
impl Clone for tdTPM_IDENTITY_CONTENTS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_IDENTITY_CONTENTS = tdTPM_IDENTITY_CONTENTS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_IDENTITY_REQ {
    pub asymSize: UINT32,
    pub symSize: UINT32,
    pub asymAlgorithm: TPM_KEY_PARMS,
    pub symAlgorithm: TPM_KEY_PARMS,
    pub asymBlob: *mut BYTE,
    pub symBlob: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_IDENTITY_REQ() {
    assert_eq!(::std::mem::size_of::<tdTPM_IDENTITY_REQ>() , 72usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_IDENTITY_REQ ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_IDENTITY_REQ>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_IDENTITY_REQ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_REQ ) ) . asymSize as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_REQ ) ,
                "::" , stringify ! ( asymSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_REQ ) ) . symSize as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_REQ ) ,
                "::" , stringify ! ( symSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_REQ ) ) . asymAlgorithm as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_REQ ) ,
                "::" , stringify ! ( asymAlgorithm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_REQ ) ) . symAlgorithm as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_REQ ) ,
                "::" , stringify ! ( symAlgorithm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_REQ ) ) . asymBlob as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_REQ ) ,
                "::" , stringify ! ( asymBlob ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_REQ ) ) . symBlob as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_REQ ) ,
                "::" , stringify ! ( symBlob ) ));
}
impl Clone for tdTPM_IDENTITY_REQ {
    fn clone(&self) -> Self { *self }
}
pub type TPM_IDENTITY_REQ = tdTPM_IDENTITY_REQ;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_IDENTITY_PROOF {
    pub ver: TPM_STRUCT_VER,
    pub labelSize: UINT32,
    pub identityBindingSize: UINT32,
    pub endorsementSize: UINT32,
    pub platformSize: UINT32,
    pub conformanceSize: UINT32,
    pub identityKey: TPM_PUBKEY,
    pub labelArea: *mut BYTE,
    pub identityBinding: *mut BYTE,
    pub endorsementCredential: *mut BYTE,
    pub platformCredential: *mut BYTE,
    pub conformanceCredential: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_IDENTITY_PROOF() {
    assert_eq!(::std::mem::size_of::<tdTPM_IDENTITY_PROOF>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_IDENTITY_PROOF )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_IDENTITY_PROOF>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_IDENTITY_PROOF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) . ver as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( ver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) . labelSize as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( labelSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) .
                identityBindingSize as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( identityBindingSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) .
                endorsementSize as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( endorsementSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) . platformSize
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( platformSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) .
                conformanceSize as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( conformanceSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) . identityKey as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( identityKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) . labelArea as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( labelArea ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) .
                identityBinding as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( identityBinding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) .
                endorsementCredential as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( endorsementCredential ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) .
                platformCredential as * const _ as usize } , 88usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( platformCredential ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_IDENTITY_PROOF ) ) .
                conformanceCredential as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_IDENTITY_PROOF )
                , "::" , stringify ! ( conformanceCredential ) ));
}
impl Clone for tdTPM_IDENTITY_PROOF {
    fn clone(&self) -> Self { *self }
}
pub type TPM_IDENTITY_PROOF = tdTPM_IDENTITY_PROOF;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_ASYM_CA_CONTENTS {
    pub sessionKey: TPM_SYMMETRIC_KEY,
    pub idDigest: TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_ASYM_CA_CONTENTS() {
    assert_eq!(::std::mem::size_of::<tdTPM_ASYM_CA_CONTENTS>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_ASYM_CA_CONTENTS )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_ASYM_CA_CONTENTS>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_ASYM_CA_CONTENTS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_ASYM_CA_CONTENTS ) ) . sessionKey
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_ASYM_CA_CONTENTS
                ) , "::" , stringify ! ( sessionKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_ASYM_CA_CONTENTS ) ) . idDigest as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_ASYM_CA_CONTENTS
                ) , "::" , stringify ! ( idDigest ) ));
}
impl Clone for tdTPM_ASYM_CA_CONTENTS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_ASYM_CA_CONTENTS = tdTPM_ASYM_CA_CONTENTS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_SYM_CA_ATTESTATION {
    pub credSize: UINT32,
    pub algorithm: TPM_KEY_PARMS,
    pub credential: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_SYM_CA_ATTESTATION() {
    assert_eq!(::std::mem::size_of::<tdTPM_SYM_CA_ATTESTATION>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_SYM_CA_ATTESTATION ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_SYM_CA_ATTESTATION>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_SYM_CA_ATTESTATION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYM_CA_ATTESTATION ) ) . credSize
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_SYM_CA_ATTESTATION ) , "::" , stringify ! ( credSize )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYM_CA_ATTESTATION ) ) . algorithm
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_SYM_CA_ATTESTATION ) , "::" , stringify ! ( algorithm )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_SYM_CA_ATTESTATION ) ) . credential
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_SYM_CA_ATTESTATION ) , "::" , stringify ! ( credential )
                ));
}
impl Clone for tdTPM_SYM_CA_ATTESTATION {
    fn clone(&self) -> Self { *self }
}
pub type TPM_SYM_CA_ATTESTATION = tdTPM_SYM_CA_ATTESTATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CURRENT_TICKS {
    pub tag: TPM_STRUCTURE_TAG,
    pub currentTicks: UINT64,
    pub tickRate: UINT16,
    pub tickNonce: TPM_NONCE,
}
#[test]
fn bindgen_test_layout_tdTPM_CURRENT_TICKS() {
    assert_eq!(::std::mem::size_of::<tdTPM_CURRENT_TICKS>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_CURRENT_TICKS ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_CURRENT_TICKS>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_CURRENT_TICKS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CURRENT_TICKS ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CURRENT_TICKS ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CURRENT_TICKS ) ) . currentTicks as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CURRENT_TICKS ) ,
                "::" , stringify ! ( currentTicks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CURRENT_TICKS ) ) . tickRate as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CURRENT_TICKS ) ,
                "::" , stringify ! ( tickRate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CURRENT_TICKS ) ) . tickNonce as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CURRENT_TICKS ) ,
                "::" , stringify ! ( tickNonce ) ));
}
impl Clone for tdTPM_CURRENT_TICKS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CURRENT_TICKS = tdTPM_CURRENT_TICKS;
pub type TPM_TRANSPORT_ATTRIBUTES = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_TRANSPORT_PUBLIC {
    pub tag: TPM_STRUCTURE_TAG,
    pub transAttributes: TPM_TRANSPORT_ATTRIBUTES,
    pub algId: TPM_ALGORITHM_ID,
    pub encScheme: TPM_ENC_SCHEME,
}
#[test]
fn bindgen_test_layout_tdTPM_TRANSPORT_PUBLIC() {
    assert_eq!(::std::mem::size_of::<tdTPM_TRANSPORT_PUBLIC>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_TRANSPORT_PUBLIC )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_TRANSPORT_PUBLIC>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_TRANSPORT_PUBLIC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_PUBLIC ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_PUBLIC
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_PUBLIC ) ) .
                transAttributes as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_PUBLIC
                ) , "::" , stringify ! ( transAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_PUBLIC ) ) . algId as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_PUBLIC
                ) , "::" , stringify ! ( algId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_PUBLIC ) ) . encScheme as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_PUBLIC
                ) , "::" , stringify ! ( encScheme ) ));
}
impl Clone for tdTPM_TRANSPORT_PUBLIC {
    fn clone(&self) -> Self { *self }
}
pub type TPM_TRANSPORT_PUBLIC = tdTPM_TRANSPORT_PUBLIC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_TRANSPORT_INTERNAL {
    pub tag: TPM_STRUCTURE_TAG,
    pub authData: TPM_AUTHDATA,
    pub transPublic: TPM_TRANSPORT_PUBLIC,
    pub transHandle: TPM_TRANSHANDLE,
    pub transNonceEven: TPM_NONCE,
    pub transDigest: TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_TRANSPORT_INTERNAL() {
    assert_eq!(::std::mem::size_of::<tdTPM_TRANSPORT_INTERNAL>() , 84usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_TRANSPORT_INTERNAL ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_TRANSPORT_INTERNAL>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_TRANSPORT_INTERNAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_INTERNAL ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_TRANSPORT_INTERNAL ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_INTERNAL ) ) . authData
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_TRANSPORT_INTERNAL ) , "::" , stringify ! ( authData )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_INTERNAL ) ) .
                transPublic as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_TRANSPORT_INTERNAL ) , "::" , stringify ! ( transPublic
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_INTERNAL ) ) .
                transHandle as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_TRANSPORT_INTERNAL ) , "::" , stringify ! ( transHandle
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_INTERNAL ) ) .
                transNonceEven as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_TRANSPORT_INTERNAL ) , "::" , stringify ! (
                transNonceEven ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_INTERNAL ) ) .
                transDigest as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_TRANSPORT_INTERNAL ) , "::" , stringify ! ( transDigest
                ) ));
}
impl Clone for tdTPM_TRANSPORT_INTERNAL {
    fn clone(&self) -> Self { *self }
}
pub type TPM_TRANSPORT_INTERNAL = tdTPM_TRANSPORT_INTERNAL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_TRANSPORT_LOG_IN {
    pub tag: TPM_STRUCTURE_TAG,
    pub parameters: TPM_DIGEST,
    pub pubKeyHash: TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_TRANSPORT_LOG_IN() {
    assert_eq!(::std::mem::size_of::<tdTPM_TRANSPORT_LOG_IN>() , 42usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_TRANSPORT_LOG_IN )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_TRANSPORT_LOG_IN>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_TRANSPORT_LOG_IN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_LOG_IN ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_LOG_IN
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_LOG_IN ) ) . parameters
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_LOG_IN
                ) , "::" , stringify ! ( parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_LOG_IN ) ) . pubKeyHash
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_LOG_IN
                ) , "::" , stringify ! ( pubKeyHash ) ));
}
impl Clone for tdTPM_TRANSPORT_LOG_IN {
    fn clone(&self) -> Self { *self }
}
pub type TPM_TRANSPORT_LOG_IN = tdTPM_TRANSPORT_LOG_IN;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_TRANSPORT_LOG_OUT {
    pub tag: TPM_STRUCTURE_TAG,
    pub currentTicks: TPM_CURRENT_TICKS,
    pub parameters: TPM_DIGEST,
    pub locality: TPM_MODIFIER_INDICATOR,
}
#[test]
fn bindgen_test_layout_tdTPM_TRANSPORT_LOG_OUT() {
    assert_eq!(::std::mem::size_of::<tdTPM_TRANSPORT_LOG_OUT>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_TRANSPORT_LOG_OUT ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_TRANSPORT_LOG_OUT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_TRANSPORT_LOG_OUT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_LOG_OUT ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_LOG_OUT
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_LOG_OUT ) ) .
                currentTicks as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_LOG_OUT
                ) , "::" , stringify ! ( currentTicks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_LOG_OUT ) ) . parameters
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_LOG_OUT
                ) , "::" , stringify ! ( parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_LOG_OUT ) ) . locality as
                * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_LOG_OUT
                ) , "::" , stringify ! ( locality ) ));
}
impl Clone for tdTPM_TRANSPORT_LOG_OUT {
    fn clone(&self) -> Self { *self }
}
pub type TPM_TRANSPORT_LOG_OUT = tdTPM_TRANSPORT_LOG_OUT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_TRANSPORT_AUTH {
    pub tag: TPM_STRUCTURE_TAG,
    pub authData: TPM_AUTHDATA,
}
#[test]
fn bindgen_test_layout_tdTPM_TRANSPORT_AUTH() {
    assert_eq!(::std::mem::size_of::<tdTPM_TRANSPORT_AUTH>() , 22usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_TRANSPORT_AUTH )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_TRANSPORT_AUTH>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_TRANSPORT_AUTH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_AUTH ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_AUTH )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_TRANSPORT_AUTH ) ) . authData as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_TRANSPORT_AUTH )
                , "::" , stringify ! ( authData ) ));
}
impl Clone for tdTPM_TRANSPORT_AUTH {
    fn clone(&self) -> Self { *self }
}
pub type TPM_TRANSPORT_AUTH = tdTPM_TRANSPORT_AUTH;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_AUDIT_EVENT_IN {
    pub tag: TPM_STRUCTURE_TAG,
    pub inputParms: TPM_DIGEST,
    pub auditCount: TPM_COUNTER_VALUE,
}
#[test]
fn bindgen_test_layout_tdTPM_AUDIT_EVENT_IN() {
    assert_eq!(::std::mem::size_of::<tdTPM_AUDIT_EVENT_IN>() , 36usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_AUDIT_EVENT_IN )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_AUDIT_EVENT_IN>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_AUDIT_EVENT_IN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_AUDIT_EVENT_IN ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_AUDIT_EVENT_IN )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_AUDIT_EVENT_IN ) ) . inputParms as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_AUDIT_EVENT_IN )
                , "::" , stringify ! ( inputParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_AUDIT_EVENT_IN ) ) . auditCount as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_AUDIT_EVENT_IN )
                , "::" , stringify ! ( auditCount ) ));
}
impl Clone for tdTPM_AUDIT_EVENT_IN {
    fn clone(&self) -> Self { *self }
}
pub type TPM_AUDIT_EVENT_IN = tdTPM_AUDIT_EVENT_IN;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_AUDIT_EVENT_OUT {
    pub tag: TPM_STRUCTURE_TAG,
    pub ordinal: TPM_COMMAND_CODE,
    pub outputParms: TPM_DIGEST,
    pub auditCount: TPM_COUNTER_VALUE,
    pub returnCode: TPM_RESULT,
}
#[test]
fn bindgen_test_layout_tdTPM_AUDIT_EVENT_OUT() {
    assert_eq!(::std::mem::size_of::<tdTPM_AUDIT_EVENT_OUT>() , 44usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_AUDIT_EVENT_OUT )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_AUDIT_EVENT_OUT>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_AUDIT_EVENT_OUT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_AUDIT_EVENT_OUT ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_AUDIT_EVENT_OUT )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_AUDIT_EVENT_OUT ) ) . ordinal as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_AUDIT_EVENT_OUT )
                , "::" , stringify ! ( ordinal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_AUDIT_EVENT_OUT ) ) . outputParms
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_AUDIT_EVENT_OUT )
                , "::" , stringify ! ( outputParms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_AUDIT_EVENT_OUT ) ) . auditCount as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_AUDIT_EVENT_OUT )
                , "::" , stringify ! ( auditCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_AUDIT_EVENT_OUT ) ) . returnCode as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_AUDIT_EVENT_OUT )
                , "::" , stringify ! ( returnCode ) ));
}
impl Clone for tdTPM_AUDIT_EVENT_OUT {
    fn clone(&self) -> Self { *self }
}
pub type TPM_AUDIT_EVENT_OUT = tdTPM_AUDIT_EVENT_OUT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CONTEXT_BLOB {
    pub tag: TPM_STRUCTURE_TAG,
    pub resourceType: TPM_RESOURCE_TYPE,
    pub handle: TPM_HANDLE,
    pub label: [BYTE; 16usize],
    pub contextCount: UINT32,
    pub integrityDigest: TPM_DIGEST,
    pub additionalSize: UINT32,
    pub additionalData: *mut BYTE,
    pub sensitiveSize: UINT32,
    pub sensitiveData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_CONTEXT_BLOB() {
    assert_eq!(::std::mem::size_of::<tdTPM_CONTEXT_BLOB>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_CONTEXT_BLOB>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_CONTEXT_BLOB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . resourceType as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( resourceType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . handle as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . label as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . contextCount as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( contextCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . integrityDigest
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( integrityDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . additionalSize
                as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( additionalSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . additionalData
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( additionalData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . sensitiveSize as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( sensitiveSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_BLOB ) ) . sensitiveData as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_BLOB ) ,
                "::" , stringify ! ( sensitiveData ) ));
}
impl Clone for tdTPM_CONTEXT_BLOB {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CONTEXT_BLOB = tdTPM_CONTEXT_BLOB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CONTEXT_SENSITIVE {
    pub tag: TPM_STRUCTURE_TAG,
    pub contextNonce: TPM_NONCE,
    pub internalSize: UINT32,
    pub internalData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_CONTEXT_SENSITIVE() {
    assert_eq!(::std::mem::size_of::<tdTPM_CONTEXT_SENSITIVE>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_CONTEXT_SENSITIVE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_CONTEXT_SENSITIVE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_CONTEXT_SENSITIVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_SENSITIVE ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_SENSITIVE
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_SENSITIVE ) ) .
                contextNonce as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_SENSITIVE
                ) , "::" , stringify ! ( contextNonce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_SENSITIVE ) ) .
                internalSize as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_SENSITIVE
                ) , "::" , stringify ! ( internalSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CONTEXT_SENSITIVE ) ) .
                internalData as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CONTEXT_SENSITIVE
                ) , "::" , stringify ! ( internalData ) ));
}
impl Clone for tdTPM_CONTEXT_SENSITIVE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CONTEXT_SENSITIVE = tdTPM_CONTEXT_SENSITIVE;
pub type TPM_NV_INDEX = UINT32;
pub type TPM_NV_PER_ATTRIBUTES = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_NV_ATTRIBUTES {
    pub tag: TPM_STRUCTURE_TAG,
    pub attributes: TPM_NV_PER_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout_tdTPM_NV_ATTRIBUTES() {
    assert_eq!(::std::mem::size_of::<tdTPM_NV_ATTRIBUTES>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_NV_ATTRIBUTES ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_NV_ATTRIBUTES>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_NV_ATTRIBUTES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_ATTRIBUTES ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_ATTRIBUTES ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_ATTRIBUTES ) ) . attributes as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_ATTRIBUTES ) ,
                "::" , stringify ! ( attributes ) ));
}
impl Clone for tdTPM_NV_ATTRIBUTES {
    fn clone(&self) -> Self { *self }
}
pub type TPM_NV_ATTRIBUTES = tdTPM_NV_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_NV_DATA_PUBLIC {
    pub tag: TPM_STRUCTURE_TAG,
    pub nvIndex: TPM_NV_INDEX,
    pub pcrInfoRead: TPM_PCR_INFO_SHORT,
    pub pcrInfoWrite: TPM_PCR_INFO_SHORT,
    pub permission: TPM_NV_ATTRIBUTES,
    pub bReadSTClear: TPM_BOOL,
    pub bWriteSTClear: TPM_BOOL,
    pub bWriteDefine: TPM_BOOL,
    pub dataSize: UINT32,
}
#[test]
fn bindgen_test_layout_tdTPM_NV_DATA_PUBLIC() {
    assert_eq!(::std::mem::size_of::<tdTPM_NV_DATA_PUBLIC>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_NV_DATA_PUBLIC>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_NV_DATA_PUBLIC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_DATA_PUBLIC ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_DATA_PUBLIC ) ) . nvIndex as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
                , "::" , stringify ! ( nvIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_DATA_PUBLIC ) ) . pcrInfoRead as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
                , "::" , stringify ! ( pcrInfoRead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_DATA_PUBLIC ) ) . pcrInfoWrite
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
                , "::" , stringify ! ( pcrInfoWrite ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_DATA_PUBLIC ) ) . permission as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
                , "::" , stringify ! ( permission ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_DATA_PUBLIC ) ) . bReadSTClear
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
                , "::" , stringify ! ( bReadSTClear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_DATA_PUBLIC ) ) . bWriteSTClear
                as * const _ as usize } , 97usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
                , "::" , stringify ! ( bWriteSTClear ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_DATA_PUBLIC ) ) . bWriteDefine
                as * const _ as usize } , 98usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
                , "::" , stringify ! ( bWriteDefine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_NV_DATA_PUBLIC ) ) . dataSize as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_NV_DATA_PUBLIC )
                , "::" , stringify ! ( dataSize ) ));
}
impl Clone for tdTPM_NV_DATA_PUBLIC {
    fn clone(&self) -> Self { *self }
}
pub type TPM_NV_DATA_PUBLIC = tdTPM_NV_DATA_PUBLIC;
pub type TPM_FAMILY_VERIFICATION = UINT32;
pub type TPM_FAMILY_ID = UINT32;
pub type TPM_DELEGATE_INDEX = UINT32;
pub type TPM_FAMILY_OPERATION = UINT32;
pub type TPM_FAMILY_FLAGS = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_FAMILY_LABEL {
    pub label: BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_FAMILY_LABEL() {
    assert_eq!(::std::mem::size_of::<tdTPM_FAMILY_LABEL>() , 1usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_FAMILY_LABEL ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_FAMILY_LABEL>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_FAMILY_LABEL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_FAMILY_LABEL ) ) . label as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_FAMILY_LABEL ) ,
                "::" , stringify ! ( label ) ));
}
impl Clone for tdTPM_FAMILY_LABEL {
    fn clone(&self) -> Self { *self }
}
pub type TPM_FAMILY_LABEL = tdTPM_FAMILY_LABEL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_FAMILY_TABLE_ENTRY {
    pub tag: TPM_STRUCTURE_TAG,
    pub label: TPM_FAMILY_LABEL,
    pub familyID: TPM_FAMILY_ID,
    pub verificationCount: TPM_FAMILY_VERIFICATION,
    pub flags: TPM_FAMILY_FLAGS,
}
#[test]
fn bindgen_test_layout_tdTPM_FAMILY_TABLE_ENTRY() {
    assert_eq!(::std::mem::size_of::<tdTPM_FAMILY_TABLE_ENTRY>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_FAMILY_TABLE_ENTRY ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_FAMILY_TABLE_ENTRY>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_FAMILY_TABLE_ENTRY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_FAMILY_TABLE_ENTRY ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_FAMILY_TABLE_ENTRY ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_FAMILY_TABLE_ENTRY ) ) . label as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_FAMILY_TABLE_ENTRY ) , "::" , stringify ! ( label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_FAMILY_TABLE_ENTRY ) ) . familyID
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_FAMILY_TABLE_ENTRY ) , "::" , stringify ! ( familyID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_FAMILY_TABLE_ENTRY ) ) .
                verificationCount as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                tdTPM_FAMILY_TABLE_ENTRY ) , "::" , stringify ! (
                verificationCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_FAMILY_TABLE_ENTRY ) ) . flags as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_FAMILY_TABLE_ENTRY ) , "::" , stringify ! ( flags ) ));
}
impl Clone for tdTPM_FAMILY_TABLE_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub type TPM_FAMILY_TABLE_ENTRY = tdTPM_FAMILY_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DELEGATE_LABEL {
    pub label: BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_DELEGATE_LABEL() {
    assert_eq!(::std::mem::size_of::<tdTPM_DELEGATE_LABEL>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_DELEGATE_LABEL ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DELEGATE_LABEL>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_DELEGATE_LABEL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_LABEL ) ) . label as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_LABEL )
                , "::" , stringify ! ( label ) ));
}
impl Clone for tdTPM_DELEGATE_LABEL {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DELEGATE_LABEL = tdTPM_DELEGATE_LABEL;
pub type TPM_DELEGATE_TYPE = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DELEGATIONS {
    pub tag: TPM_STRUCTURE_TAG,
    pub delegateType: TPM_DELEGATE_TYPE,
    pub per1: UINT32,
    pub per2: UINT32,
}
#[test]
fn bindgen_test_layout_tdTPM_DELEGATIONS() {
    assert_eq!(::std::mem::size_of::<tdTPM_DELEGATIONS>() , 16usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_DELEGATIONS ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DELEGATIONS>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_DELEGATIONS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATIONS ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATIONS ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATIONS ) ) . delegateType as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATIONS ) ,
                "::" , stringify ! ( delegateType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATIONS ) ) . per1 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATIONS ) ,
                "::" , stringify ! ( per1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATIONS ) ) . per2 as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATIONS ) ,
                "::" , stringify ! ( per2 ) ));
}
impl Clone for tdTPM_DELEGATIONS {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DELEGATIONS = tdTPM_DELEGATIONS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DELEGATE_PUBLIC {
    pub tag: TPM_STRUCTURE_TAG,
    pub label: TPM_DELEGATE_LABEL,
    pub pcrInfo: TPM_PCR_INFO_SHORT,
    pub permissions: TPM_DELEGATIONS,
    pub familyID: TPM_FAMILY_ID,
    pub verificationCount: TPM_FAMILY_VERIFICATION,
}
#[test]
fn bindgen_test_layout_tdTPM_DELEGATE_PUBLIC() {
    assert_eq!(::std::mem::size_of::<tdTPM_DELEGATE_PUBLIC>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_DELEGATE_PUBLIC )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_DELEGATE_PUBLIC>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_DELEGATE_PUBLIC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_PUBLIC ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_PUBLIC )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_PUBLIC ) ) . label as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_PUBLIC )
                , "::" , stringify ! ( label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_PUBLIC ) ) . pcrInfo as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_PUBLIC )
                , "::" , stringify ! ( pcrInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_PUBLIC ) ) . permissions
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_PUBLIC )
                , "::" , stringify ! ( permissions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_PUBLIC ) ) . familyID as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_PUBLIC )
                , "::" , stringify ! ( familyID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_PUBLIC ) ) .
                verificationCount as * const _ as usize } , 68usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_PUBLIC )
                , "::" , stringify ! ( verificationCount ) ));
}
impl Clone for tdTPM_DELEGATE_PUBLIC {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DELEGATE_PUBLIC = tdTPM_DELEGATE_PUBLIC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DELEGATE_TABLE_ROW {
    pub tag: TPM_STRUCTURE_TAG,
    pub pub_: TPM_DELEGATE_PUBLIC,
    pub authValue: TPM_SECRET,
}
#[test]
fn bindgen_test_layout_tdTPM_DELEGATE_TABLE_ROW() {
    assert_eq!(::std::mem::size_of::<tdTPM_DELEGATE_TABLE_ROW>() , 104usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_DELEGATE_TABLE_ROW ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DELEGATE_TABLE_ROW>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_DELEGATE_TABLE_ROW ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_TABLE_ROW ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_TABLE_ROW ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_TABLE_ROW ) ) . pub_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_TABLE_ROW ) , "::" , stringify ! ( pub_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_TABLE_ROW ) ) . authValue
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_TABLE_ROW ) , "::" , stringify ! ( authValue )
                ));
}
impl Clone for tdTPM_DELEGATE_TABLE_ROW {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DELEGATE_TABLE_ROW = tdTPM_DELEGATE_TABLE_ROW;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DELEGATE_SENSITIVE {
    pub tag: TPM_STRUCTURE_TAG,
    pub authValue: TPM_SECRET,
}
#[test]
fn bindgen_test_layout_tdTPM_DELEGATE_SENSITIVE() {
    assert_eq!(::std::mem::size_of::<tdTPM_DELEGATE_SENSITIVE>() , 22usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_DELEGATE_SENSITIVE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DELEGATE_SENSITIVE>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_DELEGATE_SENSITIVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_SENSITIVE ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_SENSITIVE ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_SENSITIVE ) ) . authValue
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_SENSITIVE ) , "::" , stringify ! ( authValue )
                ));
}
impl Clone for tdTPM_DELEGATE_SENSITIVE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DELEGATE_SENSITIVE = tdTPM_DELEGATE_SENSITIVE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DELEGATE_OWNER_BLOB {
    pub tag: TPM_STRUCTURE_TAG,
    pub pub_: TPM_DELEGATE_PUBLIC,
    pub integrityDigest: TPM_DIGEST,
    pub additionalSize: UINT32,
    pub additionalArea: *mut BYTE,
    pub sensitiveSize: UINT32,
    pub sensitiveArea: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_DELEGATE_OWNER_BLOB() {
    assert_eq!(::std::mem::size_of::<tdTPM_DELEGATE_OWNER_BLOB>() , 128usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_DELEGATE_OWNER_BLOB ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DELEGATE_OWNER_BLOB>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_DELEGATE_OWNER_BLOB )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_OWNER_BLOB ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_OWNER_BLOB ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_OWNER_BLOB ) ) . pub_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_OWNER_BLOB ) , "::" , stringify ! ( pub_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_OWNER_BLOB ) ) .
                integrityDigest as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_OWNER_BLOB ) , "::" , stringify ! (
                integrityDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_OWNER_BLOB ) ) .
                additionalSize as * const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_OWNER_BLOB ) , "::" , stringify ! (
                additionalSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_OWNER_BLOB ) ) .
                additionalArea as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_OWNER_BLOB ) , "::" , stringify ! (
                additionalArea ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_OWNER_BLOB ) ) .
                sensitiveSize as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_OWNER_BLOB ) , "::" , stringify ! (
                sensitiveSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_OWNER_BLOB ) ) .
                sensitiveArea as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTPM_DELEGATE_OWNER_BLOB ) , "::" , stringify ! (
                sensitiveArea ) ));
}
impl Clone for tdTPM_DELEGATE_OWNER_BLOB {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DELEGATE_OWNER_BLOB = tdTPM_DELEGATE_OWNER_BLOB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DELEGATE_KEY_BLOB {
    pub tag: TPM_STRUCTURE_TAG,
    pub pub_: TPM_DELEGATE_PUBLIC,
    pub integrityDigest: TPM_DIGEST,
    pub pubKeyDigest: TPM_DIGEST,
    pub additionalSize: UINT32,
    pub additionalArea: *mut BYTE,
    pub sensitiveSize: UINT32,
    pub sensitiveArea: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_DELEGATE_KEY_BLOB() {
    assert_eq!(::std::mem::size_of::<tdTPM_DELEGATE_KEY_BLOB>() , 152usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DELEGATE_KEY_BLOB>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_KEY_BLOB ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_KEY_BLOB ) ) . pub_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB
                ) , "::" , stringify ! ( pub_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_KEY_BLOB ) ) .
                integrityDigest as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB
                ) , "::" , stringify ! ( integrityDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_KEY_BLOB ) ) .
                pubKeyDigest as * const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB
                ) , "::" , stringify ! ( pubKeyDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_KEY_BLOB ) ) .
                additionalSize as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB
                ) , "::" , stringify ! ( additionalSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_KEY_BLOB ) ) .
                additionalArea as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB
                ) , "::" , stringify ! ( additionalArea ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_KEY_BLOB ) ) .
                sensitiveSize as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB
                ) , "::" , stringify ! ( sensitiveSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DELEGATE_KEY_BLOB ) ) .
                sensitiveArea as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DELEGATE_KEY_BLOB
                ) , "::" , stringify ! ( sensitiveArea ) ));
}
impl Clone for tdTPM_DELEGATE_KEY_BLOB {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DELEGATE_KEY_BLOB = tdTPM_DELEGATE_KEY_BLOB;
pub type TPM_CAPABILITY_AREA = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_CAP_VERSION_INFO {
    pub tag: TPM_STRUCTURE_TAG,
    pub version: TPM_VERSION,
    pub specLevel: UINT16,
    pub errataRev: BYTE,
    pub tpmVendorID: [BYTE; 4usize],
    pub vendorSpecificSize: UINT16,
    pub vendorSpecific: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_CAP_VERSION_INFO() {
    assert_eq!(::std::mem::size_of::<tdTPM_CAP_VERSION_INFO>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_CAP_VERSION_INFO )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_CAP_VERSION_INFO>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_CAP_VERSION_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CAP_VERSION_INFO ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CAP_VERSION_INFO
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CAP_VERSION_INFO ) ) . version as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CAP_VERSION_INFO
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CAP_VERSION_INFO ) ) . specLevel as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CAP_VERSION_INFO
                ) , "::" , stringify ! ( specLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CAP_VERSION_INFO ) ) . errataRev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CAP_VERSION_INFO
                ) , "::" , stringify ! ( errataRev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CAP_VERSION_INFO ) ) . tpmVendorID
                as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CAP_VERSION_INFO
                ) , "::" , stringify ! ( tpmVendorID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CAP_VERSION_INFO ) ) .
                vendorSpecificSize as * const _ as usize } , 14usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTPM_CAP_VERSION_INFO
                ) , "::" , stringify ! ( vendorSpecificSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_CAP_VERSION_INFO ) ) .
                vendorSpecific as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_CAP_VERSION_INFO
                ) , "::" , stringify ! ( vendorSpecific ) ));
}
impl Clone for tdTPM_CAP_VERSION_INFO {
    fn clone(&self) -> Self { *self }
}
pub type TPM_CAP_VERSION_INFO = tdTPM_CAP_VERSION_INFO;
pub type TPM_DA_STATE = BYTE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DA_ACTION_TYPE {
    pub tag: TPM_STRUCTURE_TAG,
    pub actions: UINT32,
}
#[test]
fn bindgen_test_layout_tdTPM_DA_ACTION_TYPE() {
    assert_eq!(::std::mem::size_of::<tdTPM_DA_ACTION_TYPE>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_DA_ACTION_TYPE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DA_ACTION_TYPE>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_DA_ACTION_TYPE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_ACTION_TYPE ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_ACTION_TYPE )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_ACTION_TYPE ) ) . actions as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_ACTION_TYPE )
                , "::" , stringify ! ( actions ) ));
}
impl Clone for tdTPM_DA_ACTION_TYPE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DA_ACTION_TYPE = tdTPM_DA_ACTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DA_INFO {
    pub tag: TPM_STRUCTURE_TAG,
    pub state: TPM_DA_STATE,
    pub currentCount: UINT16,
    pub threshholdCount: UINT16,
    pub actionAtThreshold: TPM_DA_ACTION_TYPE,
    pub actionDependValue: UINT32,
    pub vendorDataSize: UINT32,
    pub vendorData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_DA_INFO() {
    assert_eq!(::std::mem::size_of::<tdTPM_DA_INFO>() , 32usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_DA_INFO ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DA_INFO>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_DA_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO ) , "::"
                , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO ) ) . state as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO ) , "::"
                , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO ) ) . currentCount as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO ) , "::"
                , stringify ! ( currentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO ) ) . threshholdCount as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO ) , "::"
                , stringify ! ( threshholdCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO ) ) . actionAtThreshold as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO ) , "::"
                , stringify ! ( actionAtThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO ) ) . actionDependValue as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO ) , "::"
                , stringify ! ( actionDependValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO ) ) . vendorDataSize as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO ) , "::"
                , stringify ! ( vendorDataSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO ) ) . vendorData as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO ) , "::"
                , stringify ! ( vendorData ) ));
}
impl Clone for tdTPM_DA_INFO {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DA_INFO = tdTPM_DA_INFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DA_INFO_LIMITED {
    pub tag: TPM_STRUCTURE_TAG,
    pub state: TPM_DA_STATE,
    pub actionAtThreshold: TPM_DA_ACTION_TYPE,
    pub vendorDataSize: UINT32,
    pub vendorData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_DA_INFO_LIMITED() {
    assert_eq!(::std::mem::size_of::<tdTPM_DA_INFO_LIMITED>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( tdTPM_DA_INFO_LIMITED )
               ));
    assert_eq! (::std::mem::align_of::<tdTPM_DA_INFO_LIMITED>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_DA_INFO_LIMITED ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO_LIMITED ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO_LIMITED )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO_LIMITED ) ) . state as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO_LIMITED )
                , "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO_LIMITED ) ) .
                actionAtThreshold as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO_LIMITED )
                , "::" , stringify ! ( actionAtThreshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO_LIMITED ) ) .
                vendorDataSize as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO_LIMITED )
                , "::" , stringify ! ( vendorDataSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DA_INFO_LIMITED ) ) . vendorData as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DA_INFO_LIMITED )
                , "::" , stringify ! ( vendorData ) ));
}
impl Clone for tdTPM_DA_INFO_LIMITED {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DA_INFO_LIMITED = tdTPM_DA_INFO_LIMITED;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DAA_ISSUER {
    pub tag: TPM_STRUCTURE_TAG,
    pub DAA_digest_R0: TPM_DIGEST,
    pub DAA_digest_R1: TPM_DIGEST,
    pub DAA_digest_S0: TPM_DIGEST,
    pub DAA_digest_S1: TPM_DIGEST,
    pub DAA_digest_n: TPM_DIGEST,
    pub DAA_digest_gamma: TPM_DIGEST,
    pub DAA_generic_q: [BYTE; 26usize],
}
#[test]
fn bindgen_test_layout_tdTPM_DAA_ISSUER() {
    assert_eq!(::std::mem::size_of::<tdTPM_DAA_ISSUER>() , 148usize , concat !
               ( "Size of: " , stringify ! ( tdTPM_DAA_ISSUER ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DAA_ISSUER>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( tdTPM_DAA_ISSUER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_ISSUER ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_ISSUER ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_ISSUER ) ) . DAA_digest_R0 as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_ISSUER ) ,
                "::" , stringify ! ( DAA_digest_R0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_ISSUER ) ) . DAA_digest_R1 as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_ISSUER ) ,
                "::" , stringify ! ( DAA_digest_R1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_ISSUER ) ) . DAA_digest_S0 as *
                const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_ISSUER ) ,
                "::" , stringify ! ( DAA_digest_S0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_ISSUER ) ) . DAA_digest_S1 as *
                const _ as usize } , 62usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_ISSUER ) ,
                "::" , stringify ! ( DAA_digest_S1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_ISSUER ) ) . DAA_digest_n as *
                const _ as usize } , 82usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_ISSUER ) ,
                "::" , stringify ! ( DAA_digest_n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_ISSUER ) ) . DAA_digest_gamma
                as * const _ as usize } , 102usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_ISSUER ) ,
                "::" , stringify ! ( DAA_digest_gamma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_ISSUER ) ) . DAA_generic_q as *
                const _ as usize } , 122usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_ISSUER ) ,
                "::" , stringify ! ( DAA_generic_q ) ));
}
impl Clone for tdTPM_DAA_ISSUER {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DAA_ISSUER = tdTPM_DAA_ISSUER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DAA_TPM {
    pub tag: TPM_STRUCTURE_TAG,
    pub DAA_digestIssuer: TPM_DIGEST,
    pub DAA_digest_v0: TPM_DIGEST,
    pub DAA_digest_v1: TPM_DIGEST,
    pub DAA_rekey: TPM_DIGEST,
    pub DAA_count: UINT32,
}
#[test]
fn bindgen_test_layout_tdTPM_DAA_TPM() {
    assert_eq!(::std::mem::size_of::<tdTPM_DAA_TPM>() , 88usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_DAA_TPM ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DAA_TPM>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_DAA_TPM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_TPM ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_TPM ) , "::"
                , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_TPM ) ) . DAA_digestIssuer as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_TPM ) , "::"
                , stringify ! ( DAA_digestIssuer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_TPM ) ) . DAA_digest_v0 as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_TPM ) , "::"
                , stringify ! ( DAA_digest_v0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_TPM ) ) . DAA_digest_v1 as *
                const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_TPM ) , "::"
                , stringify ! ( DAA_digest_v1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_TPM ) ) . DAA_rekey as * const
                _ as usize } , 62usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_TPM ) , "::"
                , stringify ! ( DAA_rekey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_TPM ) ) . DAA_count as * const
                _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_TPM ) , "::"
                , stringify ! ( DAA_count ) ));
}
impl Clone for tdTPM_DAA_TPM {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DAA_TPM = tdTPM_DAA_TPM;
#[repr(C)]
pub struct tdTPM_DAA_CONTEXT {
    pub tag: TPM_STRUCTURE_TAG,
    pub DAA_digestContext: TPM_DIGEST,
    pub DAA_digest: TPM_DIGEST,
    pub DAA_contextSeed: TPM_DAA_CONTEXT_SEED,
    pub DAA_scratch: [BYTE; 256usize],
    pub DAA_stage: BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_DAA_CONTEXT() {
    assert_eq!(::std::mem::size_of::<tdTPM_DAA_CONTEXT>() , 320usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_DAA_CONTEXT ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DAA_CONTEXT>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_DAA_CONTEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_CONTEXT ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_CONTEXT ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_CONTEXT ) ) . DAA_digestContext
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_CONTEXT ) ,
                "::" , stringify ! ( DAA_digestContext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_CONTEXT ) ) . DAA_digest as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_CONTEXT ) ,
                "::" , stringify ! ( DAA_digest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_CONTEXT ) ) . DAA_contextSeed
                as * const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_CONTEXT ) ,
                "::" , stringify ! ( DAA_contextSeed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_CONTEXT ) ) . DAA_scratch as *
                const _ as usize } , 62usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_CONTEXT ) ,
                "::" , stringify ! ( DAA_scratch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_CONTEXT ) ) . DAA_stage as *
                const _ as usize } , 318usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_CONTEXT ) ,
                "::" , stringify ! ( DAA_stage ) ));
}
pub type TPM_DAA_CONTEXT = tdTPM_DAA_CONTEXT;
#[repr(C)]
pub struct tdTPM_DAA_JOINDATA {
    pub DAA_join_u0: [BYTE; 128usize],
    pub DAA_join_u1: [BYTE; 138usize],
    pub DAA_digest_n0: TPM_DIGEST,
}
#[test]
fn bindgen_test_layout_tdTPM_DAA_JOINDATA() {
    assert_eq!(::std::mem::size_of::<tdTPM_DAA_JOINDATA>() , 286usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_DAA_JOINDATA ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DAA_JOINDATA>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( tdTPM_DAA_JOINDATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_JOINDATA ) ) . DAA_join_u0 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_JOINDATA ) ,
                "::" , stringify ! ( DAA_join_u0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_JOINDATA ) ) . DAA_join_u1 as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_JOINDATA ) ,
                "::" , stringify ! ( DAA_join_u1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_JOINDATA ) ) . DAA_digest_n0 as
                * const _ as usize } , 266usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_JOINDATA ) ,
                "::" , stringify ! ( DAA_digest_n0 ) ));
}
pub type TPM_DAA_JOINDATA = tdTPM_DAA_JOINDATA;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DAA_BLOB {
    pub tag: TPM_STRUCTURE_TAG,
    pub resourceType: TPM_RESOURCE_TYPE,
    pub label: [BYTE; 16usize],
    pub blobIntegrity: TPM_DIGEST,
    pub additionalSize: UINT32,
    pub additionalData: *mut BYTE,
    pub sensitiveSize: UINT32,
    pub sensitiveData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_DAA_BLOB() {
    assert_eq!(::std::mem::size_of::<tdTPM_DAA_BLOB>() , 72usize , concat ! (
               "Size of: " , stringify ! ( tdTPM_DAA_BLOB ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DAA_BLOB>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTPM_DAA_BLOB ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_BLOB ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_BLOB ) , "::"
                , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_BLOB ) ) . resourceType as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_BLOB ) , "::"
                , stringify ! ( resourceType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_BLOB ) ) . label as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_BLOB ) , "::"
                , stringify ! ( label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_BLOB ) ) . blobIntegrity as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_BLOB ) , "::"
                , stringify ! ( blobIntegrity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_BLOB ) ) . additionalSize as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_BLOB ) , "::"
                , stringify ! ( additionalSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_BLOB ) ) . additionalData as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_BLOB ) , "::"
                , stringify ! ( additionalData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_BLOB ) ) . sensitiveSize as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_BLOB ) , "::"
                , stringify ! ( sensitiveSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_BLOB ) ) . sensitiveData as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_BLOB ) , "::"
                , stringify ! ( sensitiveData ) ));
}
impl Clone for tdTPM_DAA_BLOB {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DAA_BLOB = tdTPM_DAA_BLOB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTPM_DAA_SENSITIVE {
    pub tag: TPM_STRUCTURE_TAG,
    pub internalSize: UINT32,
    pub internalData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTPM_DAA_SENSITIVE() {
    assert_eq!(::std::mem::size_of::<tdTPM_DAA_SENSITIVE>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( tdTPM_DAA_SENSITIVE ) ));
    assert_eq! (::std::mem::align_of::<tdTPM_DAA_SENSITIVE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTPM_DAA_SENSITIVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_SENSITIVE ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_SENSITIVE ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_SENSITIVE ) ) . internalSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_SENSITIVE ) ,
                "::" , stringify ! ( internalSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTPM_DAA_SENSITIVE ) ) . internalData as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTPM_DAA_SENSITIVE ) ,
                "::" , stringify ! ( internalData ) ));
}
impl Clone for tdTPM_DAA_SENSITIVE {
    fn clone(&self) -> Self { *self }
}
pub type TPM_DAA_SENSITIVE = tdTPM_DAA_SENSITIVE;
pub type TPM_SYM_MODE = UINT32;
pub type UNICODE = TSS_UNICODE;
pub type TCPA_DIGEST = TPM_DIGEST;
pub type TCPA_NONCE = TPM_NONCE;
pub type TCPA_SALT_NONCE = TPM_NONCE;
pub type TCPA_PUBKEY = TPM_PUBKEY;
pub type TCPA_SECRET = TPM_SECRET;
pub type TCPA_KEY = TPM_KEY;
pub type TCPA_DIRVALUE = TPM_DIRVALUE;
pub type TCPA_COMMAND_CODE = TPM_COMMAND_CODE;
pub type TCPA_BOUND_DATA = TPM_BOUND_DATA;
pub type TCPA_VERSION = TPM_STRUCT_VER;
pub type TCPA_RESULT = TPM_RESULT;
pub type TCPA_PAYLOAD_TYPE = TPM_PAYLOAD_TYPE;
pub type TCPA_STORE_PRIVKEY = TPM_STORE_PRIVKEY;
pub type TCPA_CHOSENID_HASH = TPM_CHOSENID_HASH;
pub type TCPA_SYMMETRIC_KEY = TPM_SYMMETRIC_KEY;
pub type TCPA_PCR_INFO = TPM_PCR_INFO;
pub type TCPA_PCR_SELECTION = TPM_PCR_SELECTION;
pub type TCPA_STORED_DATA = TPM_STORED_DATA;
pub type TCPA_SEALED_DATA = TPM_SEALED_DATA;
pub type TCPA_KEY_FLAGS = TPM_KEY_FLAGS;
pub type TCPA_KEY_PARMS = TPM_KEY_PARMS;
pub type TCPA_STORE_PUBKEY = TPM_STORE_PUBKEY;
pub type TCPA_MIGRATIONKEYAUTH = TPM_MIGRATIONKEYAUTH;
pub type TCPA_RSA_KEY_PARMS = TPM_RSA_KEY_PARMS;
pub type TCPA_CERTIFY_INFO = TPM_CERTIFY_INFO;
pub type TCPA_STORE_ASYMKEY = TPM_STORE_ASYMKEY;
pub type TCPA_ENCAUTH = TPM_ENCAUTH;
pub type TCPA_PCRINDEX = TPM_PCRINDEX;
pub type TCPA_PCRVALUE = TPM_PCRVALUE;
pub type TCPA_DIRINDEX = TPM_DIRINDEX;
pub type TCPA_PROTOCOL_ID = TPM_PROTOCOL_ID;
pub type TCPA_ALGORITHM_ID = TPM_ALGORITHM_ID;
pub type TCPA_ENTITY_TYPE = TPM_ENTITY_TYPE;
pub type TCPA_CAPABILITY_AREA = TPM_CAPABILITY_AREA;
pub type TCPA_HMAC = TPM_HMAC;
pub type TCPA_MIGRATE_SCHEME = TPM_MIGRATE_SCHEME;
pub type TCPA_PHYSICAL_PRESENCE = TPM_PHYSICAL_PRESENCE;
pub type TCPA_KEY_HANDLE = TPM_KEY_HANDLE;
pub type TCPA_KEY_HANDLE_LIST = TPM_KEY_HANDLE_LIST;
pub type TCPA_PCR_COMPOSITE = TPM_PCR_COMPOSITE;
pub type TCPA_AUTH_DATA_USAGE = TPM_AUTH_DATA_USAGE;
pub type TCPA_AUTHDATA = TPM_AUTHDATA;
pub type TCPA_KEY_USAGE = TPM_KEY_USAGE;
pub type TCPA_COMPOSITE_HASH = TPM_COMPOSITE_HASH;
pub type TCPA_QUOTE_INFO = TPM_QUOTE_INFO;
pub type TCPA_TAG = TPM_TAG;
pub type TCPA_ENC_SCHEME = TPM_ENC_SCHEME;
pub type TCPA_SIG_SCHEME = TPM_SIG_SCHEME;
pub type TCPA_STARTUP_TYPE = TPM_STARTUP_TYPE;
pub type TCPA_AUTHHANDLE = TPM_AUTHHANDLE;
pub type TCPA_SYM_CA_ATTESTATION = TPM_SYM_CA_ATTESTATION;
pub type TCPA_ASYM_CA_CONTENTS = TPM_ASYM_CA_CONTENTS;
pub type TCPA_IDENTITY_REQ = TPM_IDENTITY_REQ;
pub type TCPA_IDENTITY_PROOF = TPM_IDENTITY_PROOF;
pub type TCPA_ENCHANDLE = UINT32;
pub type TCPA_EVENTTYPE = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTCPA_AUDIT_EVENT {
    pub ordinal: TCPA_COMMAND_CODE,
    pub returncode: TCPA_RESULT,
}
#[test]
fn bindgen_test_layout_tdTCPA_AUDIT_EVENT() {
    assert_eq!(::std::mem::size_of::<tdTCPA_AUDIT_EVENT>() , 8usize , concat !
               ( "Size of: " , stringify ! ( tdTCPA_AUDIT_EVENT ) ));
    assert_eq! (::std::mem::align_of::<tdTCPA_AUDIT_EVENT>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( tdTCPA_AUDIT_EVENT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCPA_AUDIT_EVENT ) ) . ordinal as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCPA_AUDIT_EVENT ) ,
                "::" , stringify ! ( ordinal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCPA_AUDIT_EVENT ) ) . returncode as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCPA_AUDIT_EVENT ) ,
                "::" , stringify ! ( returncode ) ));
}
impl Clone for tdTCPA_AUDIT_EVENT {
    fn clone(&self) -> Self { *self }
}
pub type TCPA_AUDIT_EVENT = tdTCPA_AUDIT_EVENT;
pub type TSS_HANDLE = UINT32;
pub type TSS_FLAG = UINT32;
pub type TSS_RESULT = UINT32;
pub type TSS_HOBJECT = UINT32;
pub type TSS_HCONTEXT = TSS_HOBJECT;
pub type TSS_HPOLICY = TSS_HOBJECT;
pub type TSS_HTPM = TSS_HOBJECT;
pub type TSS_HKEY = TSS_HOBJECT;
pub type TSS_HENCDATA = TSS_HOBJECT;
pub type TSS_HPCRS = TSS_HOBJECT;
pub type TSS_HHASH = TSS_HOBJECT;
pub type TSS_HNVSTORE = TSS_HOBJECT;
pub type TSS_HMIGDATA = TSS_HOBJECT;
pub type TSS_HDELFAMILY = TSS_HOBJECT;
pub type TSS_HDAA_CREDENTIAL = TSS_HOBJECT;
pub type TSS_HDAA_ISSUER_KEY = TSS_HOBJECT;
pub type TSS_HDAA_ARA_KEY = TSS_HOBJECT;
pub type TSS_EVENTTYPE = UINT32;
pub type TSS_MIGRATE_SCHEME = UINT16;
pub type TSS_ALGORITHM_ID = UINT32;
pub type TSS_KEY_USAGE_ID = UINT32;
pub type TSS_KEY_ENC_SCHEME = UINT16;
pub type TSS_KEY_SIG_SCHEME = UINT16;
pub type TSS_KEY_AUTH_DATA_USAGE = BYTE;
pub type TSS_CMK_DELEGATE = UINT32;
pub type TSS_NV_INDEX = UINT32;
pub type TSS_COUNTER_ID = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_VERSION {
    pub bMajor: BYTE,
    pub bMinor: BYTE,
    pub bRevMajor: BYTE,
    pub bRevMinor: BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_VERSION() {
    assert_eq!(::std::mem::size_of::<tdTSS_VERSION>() , 4usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_VERSION ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_VERSION>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( tdTSS_VERSION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VERSION ) ) . bMajor as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VERSION ) , "::"
                , stringify ! ( bMajor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VERSION ) ) . bMinor as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VERSION ) , "::"
                , stringify ! ( bMinor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VERSION ) ) . bRevMajor as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VERSION ) , "::"
                , stringify ! ( bRevMajor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VERSION ) ) . bRevMinor as * const
                _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VERSION ) , "::"
                , stringify ! ( bRevMinor ) ));
}
impl Clone for tdTSS_VERSION {
    fn clone(&self) -> Self { *self }
}
pub type TSS_VERSION = tdTSS_VERSION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_PCR_EVENT {
    pub versionInfo: TSS_VERSION,
    pub ulPcrIndex: UINT32,
    pub eventType: TSS_EVENTTYPE,
    pub ulPcrValueLength: UINT32,
    pub rgbPcrValue: *mut BYTE,
    pub ulEventLength: UINT32,
    pub rgbEvent: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_PCR_EVENT() {
    assert_eq!(::std::mem::size_of::<tdTSS_PCR_EVENT>() , 40usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_PCR_EVENT ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_PCR_EVENT>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tdTSS_PCR_EVENT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_EVENT ) ) . versionInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_EVENT ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_EVENT ) ) . ulPcrIndex as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_EVENT ) ,
                "::" , stringify ! ( ulPcrIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_EVENT ) ) . eventType as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_EVENT ) ,
                "::" , stringify ! ( eventType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_EVENT ) ) . ulPcrValueLength as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_EVENT ) ,
                "::" , stringify ! ( ulPcrValueLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_EVENT ) ) . rgbPcrValue as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_EVENT ) ,
                "::" , stringify ! ( rgbPcrValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_EVENT ) ) . ulEventLength as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_EVENT ) ,
                "::" , stringify ! ( ulEventLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_EVENT ) ) . rgbEvent as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_EVENT ) ,
                "::" , stringify ! ( rgbEvent ) ));
}
impl Clone for tdTSS_PCR_EVENT {
    fn clone(&self) -> Self { *self }
}
pub type TSS_PCR_EVENT = tdTSS_PCR_EVENT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_EVENT_CERT {
    pub versionInfo: TSS_VERSION,
    pub ulCertificateHashLength: UINT32,
    pub rgbCertificateHash: *mut BYTE,
    pub ulEntityDigestLength: UINT32,
    pub rgbentityDigest: *mut BYTE,
    pub fDigestChecked: TSS_BOOL,
    pub fDigestVerified: TSS_BOOL,
    pub ulIssuerLength: UINT32,
    pub rgbIssuer: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_EVENT_CERT() {
    assert_eq!(::std::mem::size_of::<tdTSS_EVENT_CERT>() , 48usize , concat !
               ( "Size of: " , stringify ! ( tdTSS_EVENT_CERT ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_EVENT_CERT>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tdTSS_EVENT_CERT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_EVENT_CERT ) ) . versionInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_EVENT_CERT ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_EVENT_CERT ) ) .
                ulCertificateHashLength as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_EVENT_CERT ) ,
                "::" , stringify ! ( ulCertificateHashLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_EVENT_CERT ) ) . rgbCertificateHash
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_EVENT_CERT ) ,
                "::" , stringify ! ( rgbCertificateHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_EVENT_CERT ) ) .
                ulEntityDigestLength as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_EVENT_CERT ) ,
                "::" , stringify ! ( ulEntityDigestLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_EVENT_CERT ) ) . rgbentityDigest as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_EVENT_CERT ) ,
                "::" , stringify ! ( rgbentityDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_EVENT_CERT ) ) . fDigestChecked as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_EVENT_CERT ) ,
                "::" , stringify ! ( fDigestChecked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_EVENT_CERT ) ) . fDigestVerified as
                * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_EVENT_CERT ) ,
                "::" , stringify ! ( fDigestVerified ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_EVENT_CERT ) ) . ulIssuerLength as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_EVENT_CERT ) ,
                "::" , stringify ! ( ulIssuerLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_EVENT_CERT ) ) . rgbIssuer as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_EVENT_CERT ) ,
                "::" , stringify ! ( rgbIssuer ) ));
}
impl Clone for tdTSS_EVENT_CERT {
    fn clone(&self) -> Self { *self }
}
pub type TSS_EVENT_CERT = tdTSS_EVENT_CERT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_UUID {
    pub ulTimeLow: UINT32,
    pub usTimeMid: UINT16,
    pub usTimeHigh: UINT16,
    pub bClockSeqHigh: BYTE,
    pub bClockSeqLow: BYTE,
    pub rgbNode: [BYTE; 6usize],
}
#[test]
fn bindgen_test_layout_tdTSS_UUID() {
    assert_eq!(::std::mem::size_of::<tdTSS_UUID>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_UUID ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_UUID>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tdTSS_UUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_UUID ) ) . ulTimeLow as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_UUID ) , "::" ,
                stringify ! ( ulTimeLow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_UUID ) ) . usTimeMid as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_UUID ) , "::" ,
                stringify ! ( usTimeMid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_UUID ) ) . usTimeHigh as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_UUID ) , "::" ,
                stringify ! ( usTimeHigh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_UUID ) ) . bClockSeqHigh as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_UUID ) , "::" ,
                stringify ! ( bClockSeqHigh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_UUID ) ) . bClockSeqLow as * const
                _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_UUID ) , "::" ,
                stringify ! ( bClockSeqLow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_UUID ) ) . rgbNode as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_UUID ) , "::" ,
                stringify ! ( rgbNode ) ));
}
impl Clone for tdTSS_UUID {
    fn clone(&self) -> Self { *self }
}
pub type TSS_UUID = tdTSS_UUID;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_KM_KEYINFO {
    pub versionInfo: TSS_VERSION,
    pub keyUUID: TSS_UUID,
    pub parentKeyUUID: TSS_UUID,
    pub bAuthDataUsage: BYTE,
    pub fIsLoaded: TSS_BOOL,
    pub ulVendorDataLength: UINT32,
    pub rgbVendorData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_KM_KEYINFO() {
    assert_eq!(::std::mem::size_of::<tdTSS_KM_KEYINFO>() , 56usize , concat !
               ( "Size of: " , stringify ! ( tdTSS_KM_KEYINFO ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_KM_KEYINFO>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tdTSS_KM_KEYINFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO ) ) . versionInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO ) ) . keyUUID as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO ) ,
                "::" , stringify ! ( keyUUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO ) ) . parentKeyUUID as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO ) ,
                "::" , stringify ! ( parentKeyUUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO ) ) . bAuthDataUsage as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO ) ,
                "::" , stringify ! ( bAuthDataUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO ) ) . fIsLoaded as *
                const _ as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO ) ,
                "::" , stringify ! ( fIsLoaded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO ) ) . ulVendorDataLength
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO ) ,
                "::" , stringify ! ( ulVendorDataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO ) ) . rgbVendorData as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO ) ,
                "::" , stringify ! ( rgbVendorData ) ));
}
impl Clone for tdTSS_KM_KEYINFO {
    fn clone(&self) -> Self { *self }
}
pub type TSS_KM_KEYINFO = tdTSS_KM_KEYINFO;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_KM_KEYINFO2 {
    pub versionInfo: TSS_VERSION,
    pub keyUUID: TSS_UUID,
    pub parentKeyUUID: TSS_UUID,
    pub bAuthDataUsage: BYTE,
    pub persistentStorageType: TSS_FLAG,
    pub persistentStorageTypeParent: TSS_FLAG,
    pub fIsLoaded: TSS_BOOL,
    pub ulVendorDataLength: UINT32,
    pub rgbVendorData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_KM_KEYINFO2() {
    assert_eq!(::std::mem::size_of::<tdTSS_KM_KEYINFO2>() , 64usize , concat !
               ( "Size of: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_KM_KEYINFO2>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTSS_KM_KEYINFO2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO2 ) ) . versionInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO2 ) ) . keyUUID as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ,
                "::" , stringify ! ( keyUUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO2 ) ) . parentKeyUUID as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ,
                "::" , stringify ! ( parentKeyUUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO2 ) ) . bAuthDataUsage as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ,
                "::" , stringify ! ( bAuthDataUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO2 ) ) .
                persistentStorageType as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ,
                "::" , stringify ! ( persistentStorageType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO2 ) ) .
                persistentStorageTypeParent as * const _ as usize } , 44usize
                , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ,
                "::" , stringify ! ( persistentStorageTypeParent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO2 ) ) . fIsLoaded as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ,
                "::" , stringify ! ( fIsLoaded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO2 ) ) .
                ulVendorDataLength as * const _ as usize } , 52usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ,
                "::" , stringify ! ( ulVendorDataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_KM_KEYINFO2 ) ) . rgbVendorData as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_KM_KEYINFO2 ) ,
                "::" , stringify ! ( rgbVendorData ) ));
}
impl Clone for tdTSS_KM_KEYINFO2 {
    fn clone(&self) -> Self { *self }
}
pub type TSS_KM_KEYINFO2 = tdTSS_KM_KEYINFO2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_NONCE {
    pub nonce: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout_tdTSS_NONCE() {
    assert_eq!(::std::mem::size_of::<tdTSS_NONCE>() , 20usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_NONCE ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_NONCE>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( tdTSS_NONCE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_NONCE ) ) . nonce as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_NONCE ) , "::" ,
                stringify ! ( nonce ) ));
}
impl Clone for tdTSS_NONCE {
    fn clone(&self) -> Self { *self }
}
pub type TSS_NONCE = tdTSS_NONCE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_VALIDATION {
    pub versionInfo: TSS_VERSION,
    pub ulExternalDataLength: UINT32,
    pub rgbExternalData: *mut BYTE,
    pub ulDataLength: UINT32,
    pub rgbData: *mut BYTE,
    pub ulValidationDataLength: UINT32,
    pub rgbValidationData: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_VALIDATION() {
    assert_eq!(::std::mem::size_of::<tdTSS_VALIDATION>() , 48usize , concat !
               ( "Size of: " , stringify ! ( tdTSS_VALIDATION ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_VALIDATION>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tdTSS_VALIDATION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VALIDATION ) ) . versionInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VALIDATION ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VALIDATION ) ) .
                ulExternalDataLength as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTSS_VALIDATION ) ,
                "::" , stringify ! ( ulExternalDataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VALIDATION ) ) . rgbExternalData as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VALIDATION ) ,
                "::" , stringify ! ( rgbExternalData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VALIDATION ) ) . ulDataLength as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VALIDATION ) ,
                "::" , stringify ! ( ulDataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VALIDATION ) ) . rgbData as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VALIDATION ) ,
                "::" , stringify ! ( rgbData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VALIDATION ) ) .
                ulValidationDataLength as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VALIDATION ) ,
                "::" , stringify ! ( ulValidationDataLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_VALIDATION ) ) . rgbValidationData
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_VALIDATION ) ,
                "::" , stringify ! ( rgbValidationData ) ));
}
impl Clone for tdTSS_VALIDATION {
    fn clone(&self) -> Self { *self }
}
pub type TSS_VALIDATION = tdTSS_VALIDATION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_CALLBACK {
    pub callback: PVOID,
    pub appData: PVOID,
    pub alg: TSS_ALGORITHM_ID,
}
#[test]
fn bindgen_test_layout_tdTSS_CALLBACK() {
    assert_eq!(::std::mem::size_of::<tdTSS_CALLBACK>() , 24usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_CALLBACK ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_CALLBACK>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTSS_CALLBACK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_CALLBACK ) ) . callback as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_CALLBACK ) , "::"
                , stringify ! ( callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_CALLBACK ) ) . appData as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_CALLBACK ) , "::"
                , stringify ! ( appData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_CALLBACK ) ) . alg as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_CALLBACK ) , "::"
                , stringify ! ( alg ) ));
}
impl Clone for tdTSS_CALLBACK {
    fn clone(&self) -> Self { *self }
}
pub type TSS_CALLBACK = tdTSS_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_PK {
    pub versionInfo: TSS_VERSION,
    pub modulusLength: UINT32,
    pub modulus: *mut BYTE,
    pub capitalSLength: UINT32,
    pub capitalS: *mut BYTE,
    pub capitalZLength: UINT32,
    pub capitalZ: *mut BYTE,
    pub capitalR0Length: UINT32,
    pub capitalR0: *mut BYTE,
    pub capitalR1Length: UINT32,
    pub capitalR1: *mut BYTE,
    pub gammaLength: UINT32,
    pub gamma: *mut BYTE,
    pub capitalGammaLength: UINT32,
    pub capitalGamma: *mut BYTE,
    pub rhoLength: UINT32,
    pub rho: *mut BYTE,
    pub capitalYLength: UINT32,
    pub capitalYLength2: UINT32,
    pub capitalY: *mut *mut BYTE,
    pub capitalYPlatformLength: UINT32,
    pub issuerBaseNameLength: UINT32,
    pub issuerBaseName: *mut BYTE,
    pub numPlatformAttributes: UINT32,
    pub numIssuerAttributes: UINT32,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_PK() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_PK>() , 168usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_PK ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_PK>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_PK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . versionInfo as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . modulusLength as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( modulusLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . modulus as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( modulus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalSLength as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalSLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalS as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalZLength as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalZLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalZ as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalZ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalR0Length as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalR0Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalR0 as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalR0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalR1Length as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalR1Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalR1 as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalR1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . gammaLength as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( gammaLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . gamma as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( gamma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalGammaLength as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalGammaLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalGamma as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalGamma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . rhoLength as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( rhoLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . rho as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( rho ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalYLength as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalYLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalYLength2 as *
                const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalYLength2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalY as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . capitalYPlatformLength
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( capitalYPlatformLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . issuerBaseNameLength
                as * const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( issuerBaseNameLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . issuerBaseName as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( issuerBaseName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . numPlatformAttributes
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( numPlatformAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK ) ) . numIssuerAttributes as
                * const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK ) , "::" ,
                stringify ! ( numIssuerAttributes ) ));
}
impl Clone for tdTSS_DAA_PK {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_PK = tdTSS_DAA_PK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_PK_PROOF {
    pub versionInfo: TSS_VERSION,
    pub challengeLength: UINT32,
    pub challenge: *mut BYTE,
    pub responseLength: UINT32,
    pub responseLength2: UINT32,
    pub response: *mut *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_PK_PROOF() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_PK_PROOF>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( tdTSS_DAA_PK_PROOF ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_PK_PROOF>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTSS_DAA_PK_PROOF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK_PROOF ) ) . versionInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK_PROOF ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK_PROOF ) ) . challengeLength
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK_PROOF ) ,
                "::" , stringify ! ( challengeLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK_PROOF ) ) . challenge as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK_PROOF ) ,
                "::" , stringify ! ( challenge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK_PROOF ) ) . responseLength
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK_PROOF ) ,
                "::" , stringify ! ( responseLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK_PROOF ) ) . responseLength2
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK_PROOF ) ,
                "::" , stringify ! ( responseLength2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PK_PROOF ) ) . response as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PK_PROOF ) ,
                "::" , stringify ! ( response ) ));
}
impl Clone for tdTSS_DAA_PK_PROOF {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_PK_PROOF = tdTSS_DAA_PK_PROOF;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_SK {
    pub versionInfo: TSS_VERSION,
    pub productPQprimeLength: UINT32,
    pub productPQprime: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_SK() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_SK>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_SK ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_SK>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_SK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SK ) ) . versionInfo as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SK ) , "::" ,
                stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SK ) ) . productPQprimeLength
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SK ) , "::" ,
                stringify ! ( productPQprimeLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SK ) ) . productPQprime as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SK ) , "::" ,
                stringify ! ( productPQprime ) ));
}
impl Clone for tdTSS_DAA_SK {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_SK = tdTSS_DAA_SK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_KEY_PAIR {
    pub versionInfo: TSS_VERSION,
    pub secretKey: TSS_DAA_SK,
    pub publicKey: TSS_DAA_PK,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_KEY_PAIR() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_KEY_PAIR>() , 192usize , concat
               ! ( "Size of: " , stringify ! ( tdTSS_DAA_KEY_PAIR ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_KEY_PAIR>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( tdTSS_DAA_KEY_PAIR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_KEY_PAIR ) ) . versionInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_KEY_PAIR ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_KEY_PAIR ) ) . secretKey as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_KEY_PAIR ) ,
                "::" , stringify ! ( secretKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_KEY_PAIR ) ) . publicKey as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_KEY_PAIR ) ,
                "::" , stringify ! ( publicKey ) ));
}
impl Clone for tdTSS_DAA_KEY_PAIR {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_KEY_PAIR = tdTSS_DAA_KEY_PAIR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_AR_PK {
    pub versionInfo: TSS_VERSION,
    pub etaLength: UINT32,
    pub eta: *mut BYTE,
    pub lambda1Length: UINT32,
    pub lambda1: *mut BYTE,
    pub lambda2Length: UINT32,
    pub lambda2: *mut BYTE,
    pub lambda3Length: UINT32,
    pub lambda3: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_AR_PK() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_AR_PK>() , 64usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_AR_PK ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_AR_PK>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tdTSS_DAA_AR_PK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_PK ) ) . versionInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_PK ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_PK ) ) . etaLength as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_PK ) ,
                "::" , stringify ! ( etaLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_PK ) ) . eta as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_PK ) ,
                "::" , stringify ! ( eta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_PK ) ) . lambda1Length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_PK ) ,
                "::" , stringify ! ( lambda1Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_PK ) ) . lambda1 as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_PK ) ,
                "::" , stringify ! ( lambda1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_PK ) ) . lambda2Length as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_PK ) ,
                "::" , stringify ! ( lambda2Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_PK ) ) . lambda2 as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_PK ) ,
                "::" , stringify ! ( lambda2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_PK ) ) . lambda3Length as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_PK ) ,
                "::" , stringify ! ( lambda3Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_PK ) ) . lambda3 as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_PK ) ,
                "::" , stringify ! ( lambda3 ) ));
}
impl Clone for tdTSS_DAA_AR_PK {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_AR_PK = tdTSS_DAA_AR_PK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_AR_SK {
    pub versionInfo: TSS_VERSION,
    pub x0Length: UINT32,
    pub x0: *mut BYTE,
    pub x1Length: UINT32,
    pub x1: *mut BYTE,
    pub x2Length: UINT32,
    pub x2: *mut BYTE,
    pub x3Length: UINT32,
    pub x3: *mut BYTE,
    pub x4Length: UINT32,
    pub x4: *mut BYTE,
    pub x5Length: UINT32,
    pub x5: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_AR_SK() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_AR_SK>() , 96usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_AR_SK ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_AR_SK>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tdTSS_DAA_AR_SK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . versionInfo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x0Length as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x0Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x0 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x1Length as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x1Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x1 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x2Length as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x2Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x3Length as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x3Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x3 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x4Length as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x4Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x4 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x5Length as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x5Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_SK ) ) . x5 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_SK ) ,
                "::" , stringify ! ( x5 ) ));
}
impl Clone for tdTSS_DAA_AR_SK {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_AR_SK = tdTSS_DAA_AR_SK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_AR_KEY_PAIR {
    pub versionInfo: TSS_VERSION,
    pub secretKey: TSS_DAA_AR_SK,
    pub publicKey: TSS_DAA_AR_PK,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_AR_KEY_PAIR() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_AR_KEY_PAIR>() , 168usize ,
               concat ! ( "Size of: " , stringify ! ( tdTSS_DAA_AR_KEY_PAIR )
               ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_AR_KEY_PAIR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_AR_KEY_PAIR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_KEY_PAIR ) ) . versionInfo
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_KEY_PAIR )
                , "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_KEY_PAIR ) ) . secretKey as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_KEY_PAIR )
                , "::" , stringify ! ( secretKey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_AR_KEY_PAIR ) ) . publicKey as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_AR_KEY_PAIR )
                , "::" , stringify ! ( publicKey ) ));
}
impl Clone for tdTSS_DAA_AR_KEY_PAIR {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_AR_KEY_PAIR = tdTSS_DAA_AR_KEY_PAIR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_CRED_ISSUER {
    pub versionInfo: TSS_VERSION,
    pub capitalALength: UINT32,
    pub capitalA: *mut BYTE,
    pub eLength: UINT32,
    pub e: *mut BYTE,
    pub vPrimePrimeLength: UINT32,
    pub vPrimePrime: *mut BYTE,
    pub attributesIssuerLength: UINT32,
    pub attributesIssuerLength2: UINT32,
    pub attributesIssuer: *mut *mut BYTE,
    pub cPrimeLength: UINT32,
    pub cPrime: *mut BYTE,
    pub sELength: UINT32,
    pub sE: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_CRED_ISSUER() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_CRED_ISSUER>() , 96usize ,
               concat ! ( "Size of: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
               ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_CRED_ISSUER>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_CRED_ISSUER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) . versionInfo
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) .
                capitalALength as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( capitalALength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) . capitalA as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( capitalA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) . eLength as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( eLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) . e as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( e ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) .
                vPrimePrimeLength as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( vPrimePrimeLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) . vPrimePrime
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( vPrimePrime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) .
                attributesIssuerLength as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( attributesIssuerLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) .
                attributesIssuerLength2 as * const _ as usize } , 52usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( attributesIssuerLength2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) .
                attributesIssuer as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( attributesIssuer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) . cPrimeLength
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( cPrimeLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) . cPrime as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( cPrime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) . sELength as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( sELength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CRED_ISSUER ) ) . sE as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CRED_ISSUER )
                , "::" , stringify ! ( sE ) ));
}
impl Clone for tdTSS_DAA_CRED_ISSUER {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_CRED_ISSUER = tdTSS_DAA_CRED_ISSUER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_CREDENTIAL {
    pub versionInfo: TSS_VERSION,
    pub capitalALength: UINT32,
    pub capitalA: *mut BYTE,
    pub exponentLength: UINT32,
    pub exponent: *mut BYTE,
    pub vBar0Length: UINT32,
    pub vBar0: *mut BYTE,
    pub vBar1Length: UINT32,
    pub vBar1: *mut BYTE,
    pub attributesLength: UINT32,
    pub attributesLength2: UINT32,
    pub attributes: *mut *mut BYTE,
    pub issuerPK: TSS_DAA_PK,
    pub tpmSpecificEncLength: UINT32,
    pub tpmSpecificEnc: *mut BYTE,
    pub daaCounter: UINT32,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_CREDENTIAL() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_CREDENTIAL>() , 272usize ,
               concat ! ( "Size of: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
               ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_CREDENTIAL>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_CREDENTIAL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . versionInfo as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . capitalALength
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( capitalALength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . capitalA as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( capitalA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . exponentLength
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( exponentLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . exponent as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( exponent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . vBar0Length as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( vBar0Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . vBar0 as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( vBar0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . vBar1Length as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( vBar1Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . vBar1 as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( vBar1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) .
                attributesLength as * const _ as usize } , 64usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( attributesLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) .
                attributesLength2 as * const _ as usize } , 68usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( attributesLength2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . attributes as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( attributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . issuerPK as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( issuerPK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) .
                tpmSpecificEncLength as * const _ as usize } , 248usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( tpmSpecificEncLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . tpmSpecificEnc
                as * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( tpmSpecificEnc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL ) ) . daaCounter as
                * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_CREDENTIAL )
                , "::" , stringify ! ( daaCounter ) ));
}
impl Clone for tdTSS_DAA_CREDENTIAL {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_CREDENTIAL = tdTSS_DAA_CREDENTIAL;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_ATTRIB_COMMIT {
    pub versionInfo: TSS_VERSION,
    pub betaLength: UINT32,
    pub beta: *mut BYTE,
    pub sMuLength: UINT32,
    pub sMu: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_ATTRIB_COMMIT() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_ATTRIB_COMMIT>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_ATTRIB_COMMIT ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_ATTRIB_COMMIT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_ATTRIB_COMMIT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_ATTRIB_COMMIT ) ) . versionInfo
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_ATTRIB_COMMIT
                ) , "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_ATTRIB_COMMIT ) ) . betaLength
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_ATTRIB_COMMIT
                ) , "::" , stringify ! ( betaLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_ATTRIB_COMMIT ) ) . beta as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_ATTRIB_COMMIT
                ) , "::" , stringify ! ( beta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_ATTRIB_COMMIT ) ) . sMuLength
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_ATTRIB_COMMIT
                ) , "::" , stringify ! ( sMuLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_ATTRIB_COMMIT ) ) . sMu as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_ATTRIB_COMMIT
                ) , "::" , stringify ! ( sMu ) ));
}
impl Clone for tdTSS_DAA_ATTRIB_COMMIT {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_ATTRIB_COMMIT = tdTSS_DAA_ATTRIB_COMMIT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_CREDENTIAL_REQUEST {
    pub versionInfo: TSS_VERSION,
    pub capitalULength: UINT32,
    pub capitalU: *mut BYTE,
    pub capitalNiLength: UINT32,
    pub capitalNi: *mut BYTE,
    pub authenticationProofLength: UINT32,
    pub authenticationProof: *mut BYTE,
    pub challengeLength: UINT32,
    pub challenge: *mut BYTE,
    pub nonceTpmLength: UINT32,
    pub nonceTpm: *mut BYTE,
    pub noncePlatformLength: UINT32,
    pub noncePlatform: *mut BYTE,
    pub sF0Length: UINT32,
    pub sF0: *mut BYTE,
    pub sF1Length: UINT32,
    pub sF1: *mut BYTE,
    pub sVprimeLength: UINT32,
    pub sVprime: *mut BYTE,
    pub sVtildePrimeLength: UINT32,
    pub sVtildePrime: *mut BYTE,
    pub sALength: UINT32,
    pub sALength2: UINT32,
    pub sA: *mut *mut BYTE,
    pub attributeCommitmentsLength: UINT32,
    pub attributeCommitments: *mut TSS_DAA_ATTRIB_COMMIT,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_CREDENTIAL_REQUEST() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_CREDENTIAL_REQUEST>() ,
               192usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_CREDENTIAL_REQUEST ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_CREDENTIAL_REQUEST>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_CREDENTIAL_REQUEST )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                versionInfo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                capitalULength as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                capitalULength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                capitalU as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! ( capitalU
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                capitalNiLength as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                capitalNiLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                capitalNi as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                capitalNi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                authenticationProofLength as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                authenticationProofLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                authenticationProof as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                authenticationProof ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                challengeLength as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                challengeLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                challenge as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                challenge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                nonceTpmLength as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                nonceTpmLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                nonceTpm as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! ( nonceTpm
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                noncePlatformLength as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                noncePlatformLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                noncePlatform as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                noncePlatform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                sF0Length as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                sF0Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) . sF0 as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! ( sF0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                sF1Length as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                sF1Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) . sF1 as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! ( sF1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                sVprimeLength as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                sVprimeLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                sVprime as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! ( sVprime
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                sVtildePrimeLength as * const _ as usize } , 144usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                sVtildePrimeLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                sVtildePrime as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                sVtildePrime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                sALength as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! ( sALength
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                sALength2 as * const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                sALength2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) . sA as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! ( sA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                attributeCommitmentsLength as * const _ as usize } , 176usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                attributeCommitmentsLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_CREDENTIAL_REQUEST ) ) .
                attributeCommitments as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_CREDENTIAL_REQUEST ) , "::" , stringify ! (
                attributeCommitments ) ));
}
impl Clone for tdTSS_DAA_CREDENTIAL_REQUEST {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_CREDENTIAL_REQUEST = tdTSS_DAA_CREDENTIAL_REQUEST;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_SELECTED_ATTRIB {
    pub versionInfo: TSS_VERSION,
    pub indicesListLength: UINT32,
    pub indicesList: *mut TSS_BOOL,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_SELECTED_ATTRIB() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_SELECTED_ATTRIB>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_SELECTED_ATTRIB ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_SELECTED_ATTRIB>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_SELECTED_ATTRIB )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SELECTED_ATTRIB ) ) .
                versionInfo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_SELECTED_ATTRIB ) , "::" , stringify ! ( versionInfo
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SELECTED_ATTRIB ) ) .
                indicesListLength as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_SELECTED_ATTRIB ) , "::" , stringify ! (
                indicesListLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SELECTED_ATTRIB ) ) .
                indicesList as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_SELECTED_ATTRIB ) , "::" , stringify ! ( indicesList
                ) ));
}
impl Clone for tdTSS_DAA_SELECTED_ATTRIB {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_SELECTED_ATTRIB = tdTSS_DAA_SELECTED_ATTRIB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_PSEUDONYM {
    pub versionInfo: TSS_VERSION,
    pub payloadFlag: TSS_FLAG,
    pub payloadLength: UINT32,
    pub payload: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_PSEUDONYM() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_PSEUDONYM>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( tdTSS_DAA_PSEUDONYM ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_PSEUDONYM>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_PSEUDONYM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM ) ) . versionInfo as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PSEUDONYM ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM ) ) . payloadFlag as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PSEUDONYM ) ,
                "::" , stringify ! ( payloadFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM ) ) . payloadLength
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PSEUDONYM ) ,
                "::" , stringify ! ( payloadLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM ) ) . payload as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_PSEUDONYM ) ,
                "::" , stringify ! ( payload ) ));
}
impl Clone for tdTSS_DAA_PSEUDONYM {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_PSEUDONYM = tdTSS_DAA_PSEUDONYM;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_PSEUDONYM_PLAIN {
    pub versionInfo: TSS_VERSION,
    pub capitalNvLength: UINT32,
    pub capitalNv: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_PSEUDONYM_PLAIN() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_PSEUDONYM_PLAIN>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_PSEUDONYM_PLAIN ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_PSEUDONYM_PLAIN>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_PSEUDONYM_PLAIN )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_PLAIN ) ) .
                versionInfo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_PLAIN ) , "::" , stringify ! ( versionInfo
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_PLAIN ) ) .
                capitalNvLength as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_PLAIN ) , "::" , stringify ! (
                capitalNvLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_PLAIN ) ) . capitalNv
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_PLAIN ) , "::" , stringify ! ( capitalNv )
                ));
}
impl Clone for tdTSS_DAA_PSEUDONYM_PLAIN {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_PSEUDONYM_PLAIN = tdTSS_DAA_PSEUDONYM_PLAIN;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_PSEUDONYM_ENCRYPTED {
    pub versionInfo: TSS_VERSION,
    pub delta1Length: UINT32,
    pub delta1: *mut BYTE,
    pub delta2Length: UINT32,
    pub delta2: *mut BYTE,
    pub delta3Length: UINT32,
    pub delta3: *mut BYTE,
    pub delta4Length: UINT32,
    pub delta4: *mut BYTE,
    pub sTauLength: UINT32,
    pub sTau: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_PSEUDONYM_ENCRYPTED() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_PSEUDONYM_ENCRYPTED>() ,
               80usize , concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_PSEUDONYM_ENCRYPTED>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_PSEUDONYM_ENCRYPTED
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                versionInfo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! (
                versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                delta1Length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! (
                delta1Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                delta1 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! ( delta1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                delta2Length as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! (
                delta2Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                delta2 as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! ( delta2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                delta3Length as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! (
                delta3Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                delta3 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! ( delta3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                delta4Length as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! (
                delta4Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                delta4 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! ( delta4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) .
                sTauLength as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! (
                sTauLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_PSEUDONYM_ENCRYPTED ) ) . sTau
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_PSEUDONYM_ENCRYPTED ) , "::" , stringify ! ( sTau )
                ));
}
impl Clone for tdTSS_DAA_PSEUDONYM_ENCRYPTED {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_PSEUDONYM_ENCRYPTED = tdTSS_DAA_PSEUDONYM_ENCRYPTED;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_SIGN_CALLBACK {
    pub versionInfo: TSS_VERSION,
    pub challenge: TSS_HHASH,
    pub payloadFlag: TSS_FLAG,
    pub payloadLength: UINT32,
    pub payload: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_SIGN_CALLBACK() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_SIGN_CALLBACK>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_SIGN_CALLBACK ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_SIGN_CALLBACK>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_SIGN_CALLBACK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGN_CALLBACK ) ) . versionInfo
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGN_CALLBACK
                ) , "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGN_CALLBACK ) ) . challenge
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGN_CALLBACK
                ) , "::" , stringify ! ( challenge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGN_CALLBACK ) ) . payloadFlag
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGN_CALLBACK
                ) , "::" , stringify ! ( payloadFlag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGN_CALLBACK ) ) .
                payloadLength as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGN_CALLBACK
                ) , "::" , stringify ! ( payloadLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGN_CALLBACK ) ) . payload as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGN_CALLBACK
                ) , "::" , stringify ! ( payload ) ));
}
impl Clone for tdTSS_DAA_SIGN_CALLBACK {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_SIGN_CALLBACK = tdTSS_DAA_SIGN_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_SIGNATURE {
    pub versionInfo: TSS_VERSION,
    pub zetaLength: UINT32,
    pub zeta: *mut BYTE,
    pub capitalTLength: UINT32,
    pub capitalT: *mut BYTE,
    pub challengeLength: UINT32,
    pub challenge: *mut BYTE,
    pub nonceTpmLength: UINT32,
    pub nonceTpm: *mut BYTE,
    pub sVLength: UINT32,
    pub sV: *mut BYTE,
    pub sF0Length: UINT32,
    pub sF0: *mut BYTE,
    pub sF1Length: UINT32,
    pub sF1: *mut BYTE,
    pub sELength: UINT32,
    pub sE: *mut BYTE,
    pub sALength: UINT32,
    pub sALength2: UINT32,
    pub sA: *mut *mut BYTE,
    pub attributeCommitmentsLength: UINT32,
    pub attributeCommitments: *mut TSS_DAA_ATTRIB_COMMIT,
    pub signedPseudonym: TSS_DAA_PSEUDONYM,
    pub callbackResult: TSS_DAA_SIGN_CALLBACK,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_SIGNATURE() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_SIGNATURE>() , 208usize ,
               concat ! ( "Size of: " , stringify ! ( tdTSS_DAA_SIGNATURE )
               ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_SIGNATURE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_SIGNATURE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . versionInfo as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( versionInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . zetaLength as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( zetaLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . zeta as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( zeta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . capitalTLength
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( capitalTLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . capitalT as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( capitalT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . challengeLength
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( challengeLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . challenge as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( challenge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . nonceTpmLength
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( nonceTpmLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . nonceTpm as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( nonceTpm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sVLength as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sVLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sV as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sF0Length as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sF0Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sF0 as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sF0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sF1Length as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sF1Length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sF1 as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sF1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sELength as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sELength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sE as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sALength as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sALength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sALength2 as *
                const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sALength2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . sA as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( sA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) .
                attributeCommitmentsLength as * const _ as usize } , 144usize
                , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( attributeCommitmentsLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) .
                attributeCommitments as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( attributeCommitments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . signedPseudonym
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( signedPseudonym ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_SIGNATURE ) ) . callbackResult
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_DAA_SIGNATURE ) ,
                "::" , stringify ! ( callbackResult ) ));
}
impl Clone for tdTSS_DAA_SIGNATURE {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_SIGNATURE = tdTSS_DAA_SIGNATURE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DAA_IDENTITY_PROOF {
    pub versionInfo: TSS_VERSION,
    pub endorsementLength: UINT32,
    pub endorsementCredential: *mut BYTE,
    pub platformLength: UINT32,
    pub platform: *mut BYTE,
    pub conformanceLength: UINT32,
    pub conformance: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_DAA_IDENTITY_PROOF() {
    assert_eq!(::std::mem::size_of::<tdTSS_DAA_IDENTITY_PROOF>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTSS_DAA_IDENTITY_PROOF ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DAA_IDENTITY_PROOF>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_DAA_IDENTITY_PROOF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_IDENTITY_PROOF ) ) .
                versionInfo as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_IDENTITY_PROOF ) , "::" , stringify ! ( versionInfo
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_IDENTITY_PROOF ) ) .
                endorsementLength as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_IDENTITY_PROOF ) , "::" , stringify ! (
                endorsementLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_IDENTITY_PROOF ) ) .
                endorsementCredential as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_IDENTITY_PROOF ) , "::" , stringify ! (
                endorsementCredential ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_IDENTITY_PROOF ) ) .
                platformLength as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_IDENTITY_PROOF ) , "::" , stringify ! (
                platformLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_IDENTITY_PROOF ) ) . platform
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_IDENTITY_PROOF ) , "::" , stringify ! ( platform )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_IDENTITY_PROOF ) ) .
                conformanceLength as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_IDENTITY_PROOF ) , "::" , stringify ! (
                conformanceLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DAA_IDENTITY_PROOF ) ) .
                conformance as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DAA_IDENTITY_PROOF ) , "::" , stringify ! ( conformance
                ) ));
}
impl Clone for tdTSS_DAA_IDENTITY_PROOF {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DAA_IDENTITY_PROOF = tdTSS_DAA_IDENTITY_PROOF;
pub type TSS_FAMILY_ID = UINT32;
pub type TSS_DELEGATION_LABEL = BYTE;
pub type TSS_DELEGATION_TYPE = UINT32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_PCR_INFO_SHORT {
    pub sizeOfSelect: UINT32,
    pub selection: *mut BYTE,
    pub localityAtRelease: BYTE,
    pub sizeOfDigestAtRelease: UINT32,
    pub digestAtRelease: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_PCR_INFO_SHORT() {
    assert_eq!(::std::mem::size_of::<tdTSS_PCR_INFO_SHORT>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( tdTSS_PCR_INFO_SHORT )
               ));
    assert_eq! (::std::mem::align_of::<tdTSS_PCR_INFO_SHORT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_PCR_INFO_SHORT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_INFO_SHORT ) ) . sizeOfSelect
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_INFO_SHORT )
                , "::" , stringify ! ( sizeOfSelect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_INFO_SHORT ) ) . selection as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_INFO_SHORT )
                , "::" , stringify ! ( selection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_INFO_SHORT ) ) .
                localityAtRelease as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_INFO_SHORT )
                , "::" , stringify ! ( localityAtRelease ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_INFO_SHORT ) ) .
                sizeOfDigestAtRelease as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_INFO_SHORT )
                , "::" , stringify ! ( sizeOfDigestAtRelease ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PCR_INFO_SHORT ) ) .
                digestAtRelease as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PCR_INFO_SHORT )
                , "::" , stringify ! ( digestAtRelease ) ));
}
impl Clone for tdTSS_PCR_INFO_SHORT {
    fn clone(&self) -> Self { *self }
}
pub type TSS_PCR_INFO_SHORT = tdTSS_PCR_INFO_SHORT;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_FAMILY_TABLE_ENTRY {
    pub familyID: TSS_FAMILY_ID,
    pub label: TSS_DELEGATION_LABEL,
    pub verificationCount: UINT32,
    pub enabled: TSS_BOOL,
    pub locked: TSS_BOOL,
}
#[test]
fn bindgen_test_layout_tdTSS_FAMILY_TABLE_ENTRY() {
    assert_eq!(::std::mem::size_of::<tdTSS_FAMILY_TABLE_ENTRY>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( tdTSS_FAMILY_TABLE_ENTRY ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_FAMILY_TABLE_ENTRY>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_FAMILY_TABLE_ENTRY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_FAMILY_TABLE_ENTRY ) ) . familyID
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_FAMILY_TABLE_ENTRY ) , "::" , stringify ! ( familyID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_FAMILY_TABLE_ENTRY ) ) . label as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_FAMILY_TABLE_ENTRY ) , "::" , stringify ! ( label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_FAMILY_TABLE_ENTRY ) ) .
                verificationCount as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                tdTSS_FAMILY_TABLE_ENTRY ) , "::" , stringify ! (
                verificationCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_FAMILY_TABLE_ENTRY ) ) . enabled as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_FAMILY_TABLE_ENTRY ) , "::" , stringify ! ( enabled )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_FAMILY_TABLE_ENTRY ) ) . locked as
                * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_FAMILY_TABLE_ENTRY ) , "::" , stringify ! ( locked ) ));
}
impl Clone for tdTSS_FAMILY_TABLE_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub type TSS_FAMILY_TABLE_ENTRY = tdTSS_FAMILY_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_DELEGATION_TABLE_ENTRY {
    pub tableIndex: UINT32,
    pub label: TSS_DELEGATION_LABEL,
    pub pcrInfo: TSS_PCR_INFO_SHORT,
    pub per1: UINT32,
    pub per2: UINT32,
    pub familyID: TSS_FAMILY_ID,
    pub verificationCount: UINT32,
}
#[test]
fn bindgen_test_layout_tdTSS_DELEGATION_TABLE_ENTRY() {
    assert_eq!(::std::mem::size_of::<tdTSS_DELEGATION_TABLE_ENTRY>() , 56usize
               , concat ! (
               "Size of: " , stringify ! ( tdTSS_DELEGATION_TABLE_ENTRY ) ));
    assert_eq! (::std::mem::align_of::<tdTSS_DELEGATION_TABLE_ENTRY>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( tdTSS_DELEGATION_TABLE_ENTRY )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DELEGATION_TABLE_ENTRY ) ) .
                tableIndex as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DELEGATION_TABLE_ENTRY ) , "::" , stringify ! (
                tableIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DELEGATION_TABLE_ENTRY ) ) . label
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DELEGATION_TABLE_ENTRY ) , "::" , stringify ! ( label )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DELEGATION_TABLE_ENTRY ) ) .
                pcrInfo as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DELEGATION_TABLE_ENTRY ) , "::" , stringify ! ( pcrInfo
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DELEGATION_TABLE_ENTRY ) ) . per1
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DELEGATION_TABLE_ENTRY ) , "::" , stringify ! ( per1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DELEGATION_TABLE_ENTRY ) ) . per2
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DELEGATION_TABLE_ENTRY ) , "::" , stringify ! ( per2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DELEGATION_TABLE_ENTRY ) ) .
                familyID as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                tdTSS_DELEGATION_TABLE_ENTRY ) , "::" , stringify ! ( familyID
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_DELEGATION_TABLE_ENTRY ) ) .
                verificationCount as * const _ as usize } , 52usize , concat !
                (
                "Alignment of field: " , stringify ! (
                tdTSS_DELEGATION_TABLE_ENTRY ) , "::" , stringify ! (
                verificationCount ) ));
}
impl Clone for tdTSS_DELEGATION_TABLE_ENTRY {
    fn clone(&self) -> Self { *self }
}
pub type TSS_DELEGATION_TABLE_ENTRY = tdTSS_DELEGATION_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTSS_PLATFORM_CLASS {
    pub platformClassSimpleIdentifier: UINT32,
    pub platformClassURISize: UINT32,
    pub pPlatformClassURI: *mut BYTE,
}
#[test]
fn bindgen_test_layout_tdTSS_PLATFORM_CLASS() {
    assert_eq!(::std::mem::size_of::<tdTSS_PLATFORM_CLASS>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( tdTSS_PLATFORM_CLASS )
               ));
    assert_eq! (::std::mem::align_of::<tdTSS_PLATFORM_CLASS>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( tdTSS_PLATFORM_CLASS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PLATFORM_CLASS ) ) .
                platformClassSimpleIdentifier as * const _ as usize } , 0usize
                , concat ! (
                "Alignment of field: " , stringify ! ( tdTSS_PLATFORM_CLASS )
                , "::" , stringify ! ( platformClassSimpleIdentifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PLATFORM_CLASS ) ) .
                platformClassURISize as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( tdTSS_PLATFORM_CLASS )
                , "::" , stringify ! ( platformClassURISize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTSS_PLATFORM_CLASS ) ) .
                pPlatformClassURI as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( tdTSS_PLATFORM_CLASS )
                , "::" , stringify ! ( pPlatformClassURI ) ));
}
impl Clone for tdTSS_PLATFORM_CLASS {
    fn clone(&self) -> Self { *self }
}
pub type TSS_PLATFORM_CLASS = tdTSS_PLATFORM_CLASS;
pub type TCS_AUTHHANDLE = UINT32;
pub type TCS_CONTEXT_HANDLE = UINT32;
pub type TCS_KEY_HANDLE = UINT32;
pub type TCS_HANDLE = UINT32;
pub type TCG_ENCAUTH = TPM_ENCAUTH;
pub type TCG_NONCE = TPM_NONCE;
pub type TCG_ENTITY_TYPE = TPM_ENTITY_TYPE;
pub type TCG_PCRINDEX = TPM_PCRINDEX;
pub type TCG_DIGEST = TPM_DIGEST;
pub type TCG_PCRVALUE = TPM_PCRVALUE;
pub type TCG_DIRVALUE = TPM_DIRVALUE;
pub type TCG_DIRINDEX = TPM_DIRINDEX;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTCS_AUTH {
    pub AuthHandle: TCS_AUTHHANDLE,
    pub NonceOdd: TPM_NONCE,
    pub NonceEven: TPM_NONCE,
    pub fContinueAuthSession: TSS_BOOL,
    pub HMAC: TPM_AUTHDATA,
}
#[test]
fn bindgen_test_layout_tdTCS_AUTH() {
    assert_eq!(::std::mem::size_of::<tdTCS_AUTH>() , 68usize , concat ! (
               "Size of: " , stringify ! ( tdTCS_AUTH ) ));
    assert_eq! (::std::mem::align_of::<tdTCS_AUTH>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tdTCS_AUTH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCS_AUTH ) ) . AuthHandle as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCS_AUTH ) , "::" ,
                stringify ! ( AuthHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCS_AUTH ) ) . NonceOdd as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCS_AUTH ) , "::" ,
                stringify ! ( NonceOdd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCS_AUTH ) ) . NonceEven as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCS_AUTH ) , "::" ,
                stringify ! ( NonceEven ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCS_AUTH ) ) . fContinueAuthSession as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCS_AUTH ) , "::" ,
                stringify ! ( fContinueAuthSession ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCS_AUTH ) ) . HMAC as * const _ as
                usize } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCS_AUTH ) , "::" ,
                stringify ! ( HMAC ) ));
}
impl Clone for tdTCS_AUTH {
    fn clone(&self) -> Self { *self }
}
pub type TCS_AUTH = tdTCS_AUTH;
pub type TPM_AUTH = TCS_AUTH;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tdTCS_LOADKEY_INFO {
    pub keyUUID: TSS_UUID,
    pub parentKeyUUID: TSS_UUID,
    pub paramDigest: TPM_DIGEST,
    pub authData: TPM_AUTH,
}
#[test]
fn bindgen_test_layout_tdTCS_LOADKEY_INFO() {
    assert_eq!(::std::mem::size_of::<tdTCS_LOADKEY_INFO>() , 120usize , concat
               ! ( "Size of: " , stringify ! ( tdTCS_LOADKEY_INFO ) ));
    assert_eq! (::std::mem::align_of::<tdTCS_LOADKEY_INFO>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( tdTCS_LOADKEY_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCS_LOADKEY_INFO ) ) . keyUUID as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCS_LOADKEY_INFO ) ,
                "::" , stringify ! ( keyUUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCS_LOADKEY_INFO ) ) . parentKeyUUID as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCS_LOADKEY_INFO ) ,
                "::" , stringify ! ( parentKeyUUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCS_LOADKEY_INFO ) ) . paramDigest as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCS_LOADKEY_INFO ) ,
                "::" , stringify ! ( paramDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tdTCS_LOADKEY_INFO ) ) . authData as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( tdTCS_LOADKEY_INFO ) ,
                "::" , stringify ! ( authData ) ));
}
impl Clone for tdTCS_LOADKEY_INFO {
    fn clone(&self) -> Self { *self }
}
pub type TCS_LOADKEY_INFO = tdTCS_LOADKEY_INFO;
extern "C" {
    pub fn Tcsi_OpenContext(hContext: *mut TCS_CONTEXT_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_CloseContext(hContext: TCS_CONTEXT_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_FreeMemory(hContext: TCS_CONTEXT_HANDLE, pMemory: *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_GetCapability(hContext: TCS_CONTEXT_HANDLE,
                              capArea: TPM_CAPABILITY_AREA,
                              subCapSize: UINT32, subCap: *mut BYTE,
                              respSize: *mut UINT32, resp: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_RegisterKey(hContext: TCS_CONTEXT_HANDLE,
                            WrappingKeyUUID: TSS_UUID, KeyUUID: TSS_UUID,
                            cKeySize: UINT32, rgbKey: *mut BYTE,
                            cVendorDataSize: UINT32, gbVendorData: *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_UnregisterKey(hContext: TCS_CONTEXT_HANDLE,
                               KeyUUID: TSS_UUID) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_KeyControlOwner(hContext: TCS_CONTEXT_HANDLE,
                                 hKey: TCS_KEY_HANDLE, ulPubKeyLength: UINT32,
                                 prgbPubKey: *mut BYTE, attribName: UINT32,
                                 attribValue: TSS_BOOL,
                                 pOwnerAuth: *mut TPM_AUTH,
                                 pUuidData: *mut TSS_UUID) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_EnumRegisteredKeys(hContext: TCS_CONTEXT_HANDLE,
                                   pKeyUUID: *mut TSS_UUID,
                                   pcKeyHierarchySize: *mut UINT32,
                                   ppKeyHierarchy: *mut *mut TSS_KM_KEYINFO)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_GetRegisteredKey(hContext: TCS_CONTEXT_HANDLE,
                                 KeyUUID: TSS_UUID,
                                 ppKeyInfo: *mut *mut TSS_KM_KEYINFO)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_GetRegisteredKeyBlob(hContext: TCS_CONTEXT_HANDLE,
                                     KeyUUID: TSS_UUID,
                                     pcKeySize: *mut UINT32,
                                     prgbKey: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_GetRegisteredKeyByPublicInfo(hContext: TCS_CONTEXT_HANDLE,
                                              algID: TSS_ALGORITHM_ID,
                                              ulPublicInfoLength: UINT32,
                                              rgbPublicInfo: *mut BYTE,
                                              keySize: *mut UINT32,
                                              keyBlob: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_LoadKeyByBlob(hContext: TCS_CONTEXT_HANDLE,
                               hUnwrappingKey: TCS_KEY_HANDLE,
                               cWrappedKeyBlobSize: UINT32,
                               rgbWrappedKeyBlob: *mut BYTE,
                               pAuth: *mut TPM_AUTH,
                               phKeyTCSI: *mut TCS_KEY_HANDLE,
                               phKeyHMAC: *mut TCS_KEY_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_LoadKeyByUUID(hContext: TCS_CONTEXT_HANDLE,
                               KeyUUID: TSS_UUID,
                               pLoadKeyInfo: *mut TCS_LOADKEY_INFO,
                               phKeyTCSI: *mut TCS_KEY_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_EvictKey(hContext: TCS_CONTEXT_HANDLE, hKey: TCS_KEY_HANDLE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CreateWrapKey(hContext: TCS_CONTEXT_HANDLE,
                               hWrappingKey: TCS_KEY_HANDLE,
                               KeyUsageAuth: TPM_ENCAUTH,
                               KeyMigrationAuth: TPM_ENCAUTH,
                               keyInfoSize: UINT32, keyInfo: *mut BYTE,
                               pAuth: *mut TPM_AUTH, keyDataSize: *mut UINT32,
                               keyData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_GetPubKey(hContext: TCS_CONTEXT_HANDLE, hKey: TCS_KEY_HANDLE,
                           pAuth: *mut TPM_AUTH, pcPubKeySize: *mut UINT32,
                           prgbPubKey: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_MakeIdentity(hContext: TCS_CONTEXT_HANDLE,
                              identityAuth: TPM_ENCAUTH,
                              IDLabel_PrivCAHash: TPM_CHOSENID_HASH,
                              idIdentityKeyInfoSize: UINT32,
                              idIdentityKeyInfo: *mut BYTE,
                              pSrkAuth: *mut TPM_AUTH,
                              pOwnerAuth: *mut TPM_AUTH,
                              idIdentityKeySize: *mut UINT32,
                              idIdentityKey: *mut *mut BYTE,
                              pcIdentityBindingSize: *mut UINT32,
                              prgbIdentityBinding: *mut *mut BYTE,
                              pcEndorsementCredentialSize: *mut UINT32,
                              prgbEndorsementCredential: *mut *mut BYTE,
                              pcPlatformCredentialSize: *mut UINT32,
                              prgbPlatformCredential: *mut *mut BYTE,
                              pcConformanceCredentialSize: *mut UINT32,
                              prgbConformanceCredential: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_MakeIdentity2(hContext: TCS_CONTEXT_HANDLE,
                               identityAuth: TPM_ENCAUTH,
                               IDLabel_PrivCAHash: TPM_CHOSENID_HASH,
                               idIdentityKeyInfoSize: UINT32,
                               idIdentityKeyInfo: *mut BYTE,
                               pSrkAuth: *mut TPM_AUTH,
                               pOwnerAuth: *mut TPM_AUTH,
                               idIdentityKeySize: *mut UINT32,
                               idIdentityKey: *mut *mut BYTE,
                               pcIdentityBindingSize: *mut UINT32,
                               prgbIdentityBinding: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_LogPcrEvent(hContext: TCS_CONTEXT_HANDLE,
                            Event: TSS_PCR_EVENT, pNumber: *mut UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_GetPcrEvent(hContext: TCS_CONTEXT_HANDLE, PcrIndex: UINT32,
                            pNumber: *mut UINT32,
                            ppEvent: *mut *mut TSS_PCR_EVENT) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_GetPcrEventsByPcr(hContext: TCS_CONTEXT_HANDLE,
                                  PcrIndex: UINT32, FirstEvent: UINT32,
                                  pEventCount: *mut UINT32,
                                  ppEvents: *mut *mut TSS_PCR_EVENT)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_GetPcrEventLog(hContext: TCS_CONTEXT_HANDLE,
                               pEventCount: *mut UINT32,
                               ppEvents: *mut *mut TSS_PCR_EVENT)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_SetOwnerInstall(hContext: TCS_CONTEXT_HANDLE,
                                 state: TSS_BOOL) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_TakeOwnership(hContext: TCS_CONTEXT_HANDLE,
                               protocolID: UINT16, encOwnerAuthSize: UINT32,
                               encOwnerAuth: *mut BYTE,
                               encSrkAuthSize: UINT32, encSrkAuth: *mut BYTE,
                               srkKeyInfoSize: UINT32, srkKeyInfo: *mut BYTE,
                               ownerAuth: *mut TPM_AUTH,
                               srkKeyDataSize: *mut UINT32,
                               srkKeyData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_SetOperatorAuth(hContext: TCS_CONTEXT_HANDLE,
                                 operatorAuth: TPM_SECRET) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_OIAP(hContext: TCS_CONTEXT_HANDLE,
                      authHandle: *mut TCS_AUTHHANDLE, nonce0: *mut TPM_NONCE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_OSAP(hContext: TCS_CONTEXT_HANDLE,
                      entityType: TPM_ENTITY_TYPE, entityValue: UINT32,
                      nonceOddOSAP: TPM_NONCE,
                      authHandle: *mut TCS_AUTHHANDLE,
                      nonceEven: *mut TPM_NONCE,
                      nonceEvenOSAP: *mut TPM_NONCE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ChangeAuth(hContext: TCS_CONTEXT_HANDLE,
                            parentHandle: TCS_KEY_HANDLE,
                            protocolID: TPM_PROTOCOL_ID, newAuth: TPM_ENCAUTH,
                            entityType: TPM_ENTITY_TYPE, encDataSize: UINT32,
                            encData: *mut BYTE, ownerAuth: *mut TPM_AUTH,
                            entityAuth: *mut TPM_AUTH,
                            outDataSize: *mut UINT32, outData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ChangeAuthOwner(hContext: TCS_CONTEXT_HANDLE,
                                 protocolID: TPM_PROTOCOL_ID,
                                 newAuth: TPM_ENCAUTH,
                                 entityType: TPM_ENTITY_TYPE,
                                 ownerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ChangeAuthAsymStart(hContext: TCS_CONTEXT_HANDLE,
                                     idHandle: TCS_KEY_HANDLE,
                                     antiReplay: TPM_NONCE,
                                     TempKeyInfoSize: UINT32,
                                     TempKeyInfoData: *mut BYTE,
                                     pAuth: *mut TPM_AUTH,
                                     TempKeySize: *mut UINT32,
                                     TempKeyData: *mut *mut BYTE,
                                     CertifyInfoSize: *mut UINT32,
                                     CertifyInfo: *mut *mut BYTE,
                                     sigSize: *mut UINT32,
                                     sig: *mut *mut BYTE,
                                     ephHandle: *mut TCS_KEY_HANDLE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ChangeAuthAsymFinish(hContext: TCS_CONTEXT_HANDLE,
                                      parentHandle: TCS_KEY_HANDLE,
                                      ephHandle: TCS_KEY_HANDLE,
                                      entityType: TPM_ENTITY_TYPE,
                                      newAuthLink: TPM_HMAC,
                                      newAuthSize: UINT32,
                                      encNewAuth: *mut BYTE,
                                      encDataSizeIn: UINT32,
                                      encDataIn: *mut BYTE,
                                      ownerAuth: *mut TPM_AUTH,
                                      encDataSizeOut: *mut UINT32,
                                      encDataOut: *mut *mut BYTE,
                                      saltNonce: *mut TPM_NONCE,
                                      changeProof: *mut TPM_DIGEST)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_TerminateHandle(hContext: TCS_CONTEXT_HANDLE,
                                 handle: TCS_AUTHHANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ActivateTPMIdentity(hContext: TCS_CONTEXT_HANDLE,
                                     idKey: TCS_KEY_HANDLE, blobSize: UINT32,
                                     blob: *mut BYTE,
                                     idKeyAuth: *mut TPM_AUTH,
                                     ownerAuth: *mut TPM_AUTH,
                                     SymmetricKeySize: *mut UINT32,
                                     SymmetricKey: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_EstablishTransport(hContext: TCS_CONTEXT_HANDLE,
                                    ulTransControlFlags: UINT32,
                                    hEncKey: TCS_KEY_HANDLE,
                                    ulTransSessionInfoSize: UINT32,
                                    rgbTransSessionInfo: *mut BYTE,
                                    ulSecretSize: UINT32,
                                    rgbSecret: *mut BYTE,
                                    pEncKeyAuth: *mut TPM_AUTH,
                                    pbLocality: *mut TPM_MODIFIER_INDICATOR,
                                    hTransSession: *mut TCS_HANDLE,
                                    ulCurrentTicksSize: *mut UINT32,
                                    prgbCurrentTicks: *mut *mut BYTE,
                                    pTransNonce: *mut TPM_NONCE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ExecuteTransport(hContext: TCS_CONTEXT_HANDLE,
                                  unWrappedCommandOrdinal: TPM_COMMAND_CODE,
                                  ulWrappedCmdParamInSize: UINT32,
                                  rgbWrappedCmdParamIn: *mut BYTE,
                                  pulHandleListSize: *mut UINT32,
                                  rghHandles: *mut *mut TCS_HANDLE,
                                  pWrappedCmdAuth1: *mut TPM_AUTH,
                                  pWrappedCmdAuth2: *mut TPM_AUTH,
                                  pTransAuth: *mut TPM_AUTH,
                                  punCurrentTicks: *mut UINT64,
                                  pbLocality: *mut TPM_MODIFIER_INDICATOR,
                                  pulWrappedCmdReturnCode: *mut TPM_RESULT,
                                  ulWrappedCmdParamOutSize: *mut UINT32,
                                  rgbWrappedCmdParamOut: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ReleaseTransportSigned(hContext: TCS_CONTEXT_HANDLE,
                                        hSignatureKey: TCS_KEY_HANDLE,
                                        AntiReplayNonce: TPM_NONCE,
                                        pKeyAuth: *mut TPM_AUTH,
                                        pTransAuth: *mut TPM_AUTH,
                                        pbLocality:
                                            *mut TPM_MODIFIER_INDICATOR,
                                        pulCurrentTicksSize: *mut UINT32,
                                        prgbCurrentTicks: *mut *mut BYTE,
                                        pulSignatureSize: *mut UINT32,
                                        prgbSignature: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Extend(hContext: TCS_CONTEXT_HANDLE, pcrNum: TPM_PCRINDEX,
                        inDigest: TPM_DIGEST, outDigest: *mut TPM_PCRVALUE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_PcrRead(hContext: TCS_CONTEXT_HANDLE, pcrNum: TPM_PCRINDEX,
                         outDigest: *mut TPM_PCRVALUE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Quote(hContext: TCS_CONTEXT_HANDLE,
                       keyHandle: TCS_KEY_HANDLE, antiReplay: TPM_NONCE,
                       pcrTargetSize: UINT32, pcrTarget: *mut BYTE,
                       privAuth: *mut TPM_AUTH, pcrDataSize: *mut UINT32,
                       pcrData: *mut *mut BYTE, sigSize: *mut UINT32,
                       sig: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Quote2(hContext: TCS_CONTEXT_HANDLE,
                        keyHandle: TCS_KEY_HANDLE, antiReplay: TPM_NONCE,
                        pcrTargetSize: UINT32, pcrTarget: *mut BYTE,
                        addVersion: TSS_BOOL, privAuth: *mut TPM_AUTH,
                        pcrDataSize: *mut UINT32, pcrData: *mut *mut BYTE,
                        versionInfoSize: *mut UINT32,
                        versionInfo: *mut *mut BYTE, sigSize: *mut UINT32,
                        sig: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_DirWriteAuth(hContext: TCS_CONTEXT_HANDLE,
                              dirIndex: TPM_DIRINDEX,
                              newContents: TPM_DIRVALUE,
                              ownerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_DirRead(hContext: TCS_CONTEXT_HANDLE, dirIndex: TPM_DIRINDEX,
                         dirValue: *mut TPM_DIRVALUE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Seal(hContext: TCS_CONTEXT_HANDLE, keyHandle: TCS_KEY_HANDLE,
                      encAuth: TPM_ENCAUTH, pcrInfoSize: UINT32,
                      PcrInfo: *mut BYTE, inDataSize: UINT32,
                      inData: *mut BYTE, pubAuth: *mut TPM_AUTH,
                      SealedDataSize: *mut UINT32, SealedData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Unseal(hContext: TCS_CONTEXT_HANDLE,
                        keyHandle: TCS_KEY_HANDLE, SealedDataSize: UINT32,
                        SealedData: *mut BYTE, keyAuth: *mut TPM_AUTH,
                        dataAuth: *mut TPM_AUTH, DataSize: *mut UINT32,
                        Data: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_UnBind(hContext: TCS_CONTEXT_HANDLE,
                        keyHandle: TCS_KEY_HANDLE, inDataSize: UINT32,
                        inData: *mut BYTE, privAuth: *mut TPM_AUTH,
                        outDataSize: *mut UINT32, outData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Sealx(hContext: TCS_CONTEXT_HANDLE,
                       keyHandle: TCS_KEY_HANDLE, encAuth: TPM_ENCAUTH,
                       pcrInfoSize: UINT32, PcrInfo: *mut BYTE,
                       inDataSize: UINT32, inData: *mut BYTE,
                       pubAuth: *mut TPM_AUTH, SealedDataSize: *mut UINT32,
                       SealedData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_LoadKey2ByBlob(hContext: TCS_CONTEXT_HANDLE,
                                hUnwrappingKey: TCS_KEY_HANDLE,
                                cWrappedKeyBlobSize: UINT32,
                                rgbWrappedKeyBlob: *mut BYTE,
                                pAuth: *mut TPM_AUTH,
                                phKeyTCSI: *mut TCS_KEY_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CreateMigrationBlob(hContext: TCS_CONTEXT_HANDLE,
                                     parentHandle: TCS_KEY_HANDLE,
                                     migrationType: TSS_MIGRATE_SCHEME,
                                     MigrationKeyAuthSize: UINT32,
                                     MigrationKeyAuth: *mut BYTE,
                                     encDataSize: UINT32, encData: *mut BYTE,
                                     parentAuth: *mut TPM_AUTH,
                                     entityAuth: *mut TPM_AUTH,
                                     randomSize: *mut UINT32,
                                     random: *mut *mut BYTE,
                                     outDataSize: *mut UINT32,
                                     outData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ConvertMigrationBlob(hContext: TCS_CONTEXT_HANDLE,
                                      parentHandle: TCS_KEY_HANDLE,
                                      inDataSize: UINT32, inData: *mut BYTE,
                                      randomSize: UINT32, random: *mut BYTE,
                                      parentAuth: *mut TPM_AUTH,
                                      outDataSize: *mut UINT32,
                                      outData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_AuthorizeMigrationKey(hContext: TCS_CONTEXT_HANDLE,
                                       migrateScheme: TSS_MIGRATE_SCHEME,
                                       MigrationKeySize: UINT32,
                                       MigrationKey: *mut BYTE,
                                       ownerAuth: *mut TPM_AUTH,
                                       MigrationKeyAuthSize: *mut UINT32,
                                       MigrationKeyAuth: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CertifyKey(hContext: TCS_CONTEXT_HANDLE,
                            certHandle: TCS_KEY_HANDLE,
                            keyHandle: TCS_KEY_HANDLE, antiReplay: TPM_NONCE,
                            certAuth: *mut TPM_AUTH, keyAuth: *mut TPM_AUTH,
                            CertifyInfoSize: *mut UINT32,
                            CertifyInfo: *mut *mut BYTE,
                            outDataSize: *mut UINT32, outData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CertifyKey2(hContext: TCS_CONTEXT_HANDLE,
                             certHandle: TCS_KEY_HANDLE,
                             keyHandle: TCS_KEY_HANDLE, MSAdigest: TPM_DIGEST,
                             antiReplay: TPM_NONCE, certAuth: *mut TPM_AUTH,
                             keyAuth: *mut TPM_AUTH,
                             CertifyInfoSize: *mut UINT32,
                             CertifyInfo: *mut *mut BYTE,
                             outDataSize: *mut UINT32,
                             outData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Sign(hContext: TCS_CONTEXT_HANDLE, keyHandle: TCS_KEY_HANDLE,
                      areaToSignSize: UINT32, areaToSign: *mut BYTE,
                      privAuth: *mut TPM_AUTH, sigSize: *mut UINT32,
                      sig: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_GetRandom(hContext: TCS_CONTEXT_HANDLE,
                           bytesRequested: *mut UINT32,
                           randomBytes: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_StirRandom(hContext: TCS_CONTEXT_HANDLE, inDataSize: UINT32,
                            inData: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_GetCapability(hContext: TCS_CONTEXT_HANDLE,
                               capArea: TPM_CAPABILITY_AREA,
                               subCapSize: UINT32, subCap: *mut BYTE,
                               respSize: *mut UINT32, resp: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_GetCapabilitySigned(hContext: TCS_CONTEXT_HANDLE,
                                     keyHandle: TCS_KEY_HANDLE,
                                     antiReplay: TPM_NONCE,
                                     capArea: TPM_CAPABILITY_AREA,
                                     subCapSize: UINT32, subCap: *mut BYTE,
                                     privAuth: *mut TPM_AUTH,
                                     Version: *mut TPM_VERSION,
                                     respSize: *mut UINT32,
                                     resp: *mut *mut BYTE,
                                     sigSize: *mut UINT32,
                                     sig: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_GetCapabilityOwner(hContext: TCS_CONTEXT_HANDLE,
                                    pOwnerAuth: *mut TPM_AUTH,
                                    pVersion: *mut TPM_VERSION,
                                    pNonVolatileFlags: *mut UINT32,
                                    pVolatileFlags: *mut UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CreateEndorsementKeyPair(hContext: TCS_CONTEXT_HANDLE,
                                          antiReplay: TPM_NONCE,
                                          endorsementKeyInfoSize: UINT32,
                                          endorsementKeyInfo: *mut BYTE,
                                          endorsementKeySize: *mut UINT32,
                                          endorsementKey: *mut *mut BYTE,
                                          checksum: *mut TPM_DIGEST)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ReadPubek(hContext: TCS_CONTEXT_HANDLE,
                           antiReplay: TPM_NONCE,
                           pubEndorsementKeySize: *mut UINT32,
                           pubEndorsementKey: *mut *mut BYTE,
                           checksum: *mut TPM_DIGEST) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_DisablePubekRead(hContext: TCS_CONTEXT_HANDLE,
                                  ownerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_OwnerReadPubek(hContext: TCS_CONTEXT_HANDLE,
                                ownerAuth: *mut TPM_AUTH,
                                pubEndorsementKeySize: *mut UINT32,
                                pubEndorsementKey: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_SelfTestFull(hContext: TCS_CONTEXT_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CertifySelfTest(hContext: TCS_CONTEXT_HANDLE,
                                 keyHandle: TCS_KEY_HANDLE,
                                 antiReplay: TPM_NONCE,
                                 privAuth: *mut TPM_AUTH,
                                 sigSize: *mut UINT32, sig: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ContinueSelfTest(hContext: TCS_CONTEXT_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_GetTestResult(hContext: TCS_CONTEXT_HANDLE,
                               outDataSize: *mut UINT32,
                               outData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_OwnerSetDisable(hContext: TCS_CONTEXT_HANDLE,
                                 disableState: TSS_BOOL,
                                 ownerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_OwnerClear(hContext: TCS_CONTEXT_HANDLE,
                            ownerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_DisableOwnerClear(hContext: TCS_CONTEXT_HANDLE,
                                   ownerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ForceClear(hContext: TCS_CONTEXT_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_DisableForceClear(hContext: TCS_CONTEXT_HANDLE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_PhysicalDisable(hContext: TCS_CONTEXT_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_PhysicalEnable(hContext: TCS_CONTEXT_HANDLE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_PhysicalSetDeactivated(hContext: TCS_CONTEXT_HANDLE,
                                        state: TSS_BOOL) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_SetTempDeactivated(hContext: TCS_CONTEXT_HANDLE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_SetTempDeactivated2(hContext: TCS_CONTEXT_HANDLE,
                                     pOperatorAuth: *mut TPM_AUTH)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_OwnerReadInternalPub(hContext: TCS_CONTEXT_HANDLE,
                                      hKey: TCS_KEY_HANDLE,
                                      pOwnerAuth: *mut TPM_AUTH,
                                      punPubKeySize: *mut UINT32,
                                      ppbPubKeyData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_PhysicalPresence(hContext: TCS_CONTEXT_HANDLE,
                                  fPhysicalPresence: TPM_PHYSICAL_PRESENCE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_FieldUpgrade(hContext: TCS_CONTEXT_HANDLE,
                              dataInSize: UINT32, dataIn: *mut BYTE,
                              ownerAuth: *mut TPM_AUTH,
                              dataOutSize: *mut UINT32,
                              dataOut: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ResetLockValue(hContext: TCS_CONTEXT_HANDLE,
                                ownerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_FlushSpecific(hContext: TCS_CONTEXT_HANDLE,
                               hResHandle: TCS_HANDLE,
                               resourceType: TPM_RESOURCE_TYPE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_SetRedirection(hContext: TCS_CONTEXT_HANDLE,
                                keyHandle: TCS_KEY_HANDLE, c1: UINT32,
                                c2: UINT32, privAuth: *mut TPM_AUTH)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_DSAP(hContext: TCS_CONTEXT_HANDLE,
                      entityType: TPM_ENTITY_TYPE, keyHandle: TCS_KEY_HANDLE,
                      nonceOddDSAP: TPM_NONCE, entityValueSize: UINT32,
                      entityValue: *mut BYTE, authHandle: *mut TCS_AUTHHANDLE,
                      nonceEven: *mut TPM_NONCE,
                      nonceEvenDSAP: *mut TPM_NONCE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Delegate_Manage(hContext: TCS_CONTEXT_HANDLE,
                                 familyID: TPM_FAMILY_ID,
                                 opFlag: TPM_FAMILY_OPERATION,
                                 opDataSize: UINT32, opData: *mut BYTE,
                                 ownerAuth: *mut TPM_AUTH,
                                 retDataSize: *mut UINT32,
                                 retData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Delegate_CreateKeyDelegation(hContext: TCS_CONTEXT_HANDLE,
                                              hKey: TCS_KEY_HANDLE,
                                              publicInfoSize: UINT32,
                                              publicInfo: *mut BYTE,
                                              encDelAuth: TPM_ENCAUTH,
                                              keyAuth: *mut TPM_AUTH,
                                              blobSize: *mut UINT32,
                                              blob: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Delegate_CreateOwnerDelegation(hContext: TCS_CONTEXT_HANDLE,
                                                increment: TSS_BOOL,
                                                publicInfoSize: UINT32,
                                                publicInfo: *mut BYTE,
                                                encDelAuth: TPM_ENCAUTH,
                                                ownerAuth: *mut TPM_AUTH,
                                                blobSize: *mut UINT32,
                                                blob: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Delegate_LoadOwnerDelegation(hContext: TCS_CONTEXT_HANDLE,
                                              index: TPM_DELEGATE_INDEX,
                                              blobSize: UINT32,
                                              blob: *mut BYTE,
                                              ownerAuth: *mut TPM_AUTH)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Delegate_UpdateVerificationCount(hContext:
                                                      TCS_CONTEXT_HANDLE,
                                                  inputSize: UINT32,
                                                  input: *mut BYTE,
                                                  ownerAuth: *mut TPM_AUTH,
                                                  outputSize: *mut UINT32,
                                                  output: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Delegate_VerifyDelegation(hContext: TCS_CONTEXT_HANDLE,
                                           delegateSize: UINT32,
                                           delegate: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_Delegate_ReadTable(hContext: TCS_CONTEXT_HANDLE,
                                    pulFamilyTableSize: *mut UINT32,
                                    ppFamilyTable: *mut *mut BYTE,
                                    pulDelegateTableSize: *mut UINT32,
                                    ppDelegateTable: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_NV_DefineOrReleaseSpace(hContext: TCS_CONTEXT_HANDLE,
                                         cPubInfoSize: UINT32,
                                         pPubInfo: *mut BYTE,
                                         encAuth: TPM_ENCAUTH,
                                         pAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_NV_WriteValue(hContext: TCS_CONTEXT_HANDLE,
                               hNVStore: TSS_NV_INDEX, offset: UINT32,
                               ulDataLength: UINT32,
                               rgbDataToWrite: *mut BYTE,
                               privAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_NV_WriteValueAuth(hContext: TCS_CONTEXT_HANDLE,
                                   hNVStore: TSS_NV_INDEX, offset: UINT32,
                                   ulDataLength: UINT32,
                                   rgbDataToWrite: *mut BYTE,
                                   NVAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_NV_ReadValue(hContext: TCS_CONTEXT_HANDLE,
                              hNVStore: TSS_NV_INDEX, offset: UINT32,
                              pulDataLength: *mut UINT32,
                              privAuth: *mut TPM_AUTH,
                              rgbDataRead: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_NV_ReadValueAuth(hContext: TCS_CONTEXT_HANDLE,
                                  hNVStore: TSS_NV_INDEX, offset: UINT32,
                                  pulDataLength: *mut UINT32,
                                  NVAuth: *mut TPM_AUTH,
                                  rgbDataRead: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CreateMaintenanceArchive(hContext: TCS_CONTEXT_HANDLE,
                                          generateRandom: TSS_BOOL,
                                          ownerAuth: *mut TPM_AUTH,
                                          randomSize: *mut UINT32,
                                          random: *mut *mut BYTE,
                                          archiveSize: *mut UINT32,
                                          archive: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_LoadMaintenanceArchive(hContext: TCS_CONTEXT_HANDLE,
                                        dataInSize: UINT32, dataIn: *mut BYTE,
                                        ownerAuth: *mut TPM_AUTH,
                                        dataOutSize: *mut UINT32,
                                        dataOut: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_KillMaintenanceFeature(hContext: TCS_CONTEXT_HANDLE,
                                        ownerAuth: *mut TPM_AUTH)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_LoadManuMaintPub(hContext: TCS_CONTEXT_HANDLE,
                                  antiReplay: TPM_NONCE, PubKeySize: UINT32,
                                  PubKey: *mut BYTE,
                                  checksum: *mut TPM_DIGEST) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ReadManuMaintPub(hContext: TCS_CONTEXT_HANDLE,
                                  antiReplay: TPM_NONCE,
                                  checksum: *mut TPM_DIGEST) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CreateRevocableEndorsementKeyPair(hContext:
                                                       TCS_CONTEXT_HANDLE,
                                                   antiReplay: TPM_NONCE,
                                                   endorsementKeyInfoSize:
                                                       UINT32,
                                                   endorsementKeyInfo:
                                                       *mut BYTE,
                                                   GenResetAuth: TSS_BOOL,
                                                   EKResetAuth:
                                                       *mut TPM_DIGEST,
                                                   endorsementKeySize:
                                                       *mut UINT32,
                                                   endorsementKey:
                                                       *mut *mut BYTE,
                                                   checksum: *mut TPM_DIGEST)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_RevokeEndorsementKeyPair(hContext: TCS_CONTEXT_HANDLE,
                                          EKResetAuth: TPM_DIGEST)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_PcrReset(hContext: TCS_CONTEXT_HANDLE, pcrTargetSize: UINT32,
                          pcrTarget: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ReadCounter(hContext: TCS_CONTEXT_HANDLE,
                             idCounter: TSS_COUNTER_ID,
                             counterValue: *mut TPM_COUNTER_VALUE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CreateCounter(hContext: TCS_CONTEXT_HANDLE,
                               LabelSize: UINT32, pLabel: *mut BYTE,
                               CounterAuth: TPM_ENCAUTH,
                               pOwnerAuth: *mut TPM_AUTH,
                               idCounter: *mut TSS_COUNTER_ID,
                               counterValue: *mut TPM_COUNTER_VALUE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_IncrementCounter(hContext: TCS_CONTEXT_HANDLE,
                                  idCounter: TSS_COUNTER_ID,
                                  pCounterAuth: *mut TPM_AUTH,
                                  counterValue: *mut TPM_COUNTER_VALUE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ReleaseCounter(hContext: TCS_CONTEXT_HANDLE,
                                idCounter: TSS_COUNTER_ID,
                                pCounterAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ReleaseCounterOwner(hContext: TCS_CONTEXT_HANDLE,
                                     idCounter: TSS_COUNTER_ID,
                                     pOwnerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_ReadCurrentTicks(hContext: TCS_CONTEXT_HANDLE,
                                  pulCurrentTimeSize: *mut UINT32,
                                  prgbCurrentTime: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_TickStampBlob(hContext: TCS_CONTEXT_HANDLE,
                               hKey: TCS_KEY_HANDLE, antiReplay: TPM_NONCE,
                               digestToStamp: TPM_DIGEST,
                               privAuth: *mut TPM_AUTH,
                               pulSignatureLength: *mut UINT32,
                               prgbSignature: *mut *mut BYTE,
                               pulTickCountSize: *mut UINT32,
                               prgbTickCount: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_TPM_DAA_Join(hContext: TCS_CONTEXT_HANDLE,
                              handle: TPM_HANDLE, stage: BYTE,
                              inputSize0: UINT32, inputData0: *mut BYTE,
                              inputSize1: UINT32, inputData1: *mut BYTE,
                              ownerAuth: *mut TPM_AUTH,
                              outputSize: *mut UINT32,
                              outputData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_TPM_DAA_Sign(hContext: TCS_CONTEXT_HANDLE,
                              handle: TPM_HANDLE, stage: BYTE,
                              inputSize0: UINT32, inputData0: *mut BYTE,
                              inputSize1: UINT32, inputData1: *mut BYTE,
                              ownerAuth: *mut TPM_AUTH,
                              outputSize: *mut UINT32,
                              outputData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_MigrateKey(hContext: TCS_CONTEXT_HANDLE,
                            hMaKey: TCS_KEY_HANDLE, PublicKeySize: UINT32,
                            PublicKey: *mut BYTE, inDataSize: UINT32,
                            inData: *mut BYTE, ownerAuth: *mut TPM_AUTH,
                            outDataSize: *mut UINT32, outData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CMK_SetRestrictions(hContext: TCS_CONTEXT_HANDLE,
                                     Restriction: TSS_CMK_DELEGATE,
                                     ownerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CMK_ApproveMA(hContext: TCS_CONTEXT_HANDLE,
                               migAuthorityDigest: TPM_DIGEST,
                               ownerAuth: *mut TPM_AUTH,
                               HmacMigAuthDigest: *mut TPM_HMAC)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CMK_CreateKey(hContext: TCS_CONTEXT_HANDLE,
                               hWrappingKey: TCS_KEY_HANDLE,
                               KeyUsageAuth: TPM_ENCAUTH,
                               MigAuthApproval: TPM_HMAC,
                               MigAuthorityDigest: TPM_DIGEST,
                               keyDataSize: *mut UINT32,
                               prgbKeyData: *mut *mut BYTE,
                               pAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CMK_CreateTicket(hContext: TCS_CONTEXT_HANDLE,
                                  PublicVerifyKeySize: UINT32,
                                  PublicVerifyKey: *mut BYTE,
                                  SignedData: TPM_DIGEST,
                                  SigValueSize: UINT32, SigValue: *mut BYTE,
                                  pOwnerAuth: *mut TPM_AUTH,
                                  SigTicket: *mut TPM_HMAC) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CMK_CreateBlob(hContext: TCS_CONTEXT_HANDLE,
                                parentHandle: TCS_KEY_HANDLE,
                                migrationType: TSS_MIGRATE_SCHEME,
                                MigrationKeyAuthSize: UINT32,
                                MigrationKeyAuth: *mut BYTE,
                                PubSourceKeyDigest: TPM_DIGEST,
                                msaListSize: UINT32, msaList: *mut BYTE,
                                restrictTicketSize: UINT32,
                                restrictTicket: *mut BYTE,
                                sigTicketSize: UINT32, sigTicket: *mut BYTE,
                                encDataSize: UINT32, encData: *mut BYTE,
                                parentAuth: *mut TPM_AUTH,
                                randomSize: *mut UINT32,
                                random: *mut *mut BYTE,
                                outDataSize: *mut UINT32,
                                outData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_CMK_ConvertMigration(hContext: TCS_CONTEXT_HANDLE,
                                      parentHandle: TCS_KEY_HANDLE,
                                      restrictTicket: TPM_CMK_AUTH,
                                      sigTicket: TPM_HMAC,
                                      keyDataSize: UINT32,
                                      prgbKeyData: *mut BYTE,
                                      msaListSize: UINT32, msaList: *mut BYTE,
                                      randomSize: UINT32, random: *mut BYTE,
                                      parentAuth: *mut TPM_AUTH,
                                      outDataSize: *mut UINT32,
                                      outData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_SetCapability(hContext: TCS_CONTEXT_HANDLE,
                               capArea: TPM_CAPABILITY_AREA,
                               subCapSize: UINT32, subCap: *mut BYTE,
                               valueSize: UINT32, value: *mut BYTE,
                               ownerAuth: *mut TPM_AUTH) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_GetAuditDigest(hContext: TCS_CONTEXT_HANDLE,
                                startOrdinal: UINT32,
                                auditDigest: *mut TPM_DIGEST,
                                counterValueSize: *mut UINT32,
                                counterValue: *mut *mut BYTE,
                                more: *mut TSS_BOOL, ordSize: *mut UINT32,
                                ordList: *mut *mut UINT32) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_GetAuditDigestSigned(hContext: TCS_CONTEXT_HANDLE,
                                      keyHandle: TCS_KEY_HANDLE,
                                      closeAudit: TSS_BOOL,
                                      antiReplay: TPM_NONCE,
                                      privAuth: *mut TPM_AUTH,
                                      counterValueSize: *mut UINT32,
                                      counterValue: *mut *mut BYTE,
                                      auditDigest: *mut TPM_DIGEST,
                                      ordinalDigest: *mut TPM_DIGEST,
                                      sigSize: *mut UINT32,
                                      sig: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsip_SetOrdinalAuditStatus(hContext: TCS_CONTEXT_HANDLE,
                                       ordinalToAudit: UINT32,
                                       auditState: TSS_BOOL,
                                       ownerAuth: *mut TPM_AUTH)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_Admin_TSS_SessionsPerLocality(hContext: TCS_CONTEXT_HANDLE,
                                              ulLocality: UINT32,
                                              ulSessions: UINT32,
                                              pOwnerAuth: *mut TPM_AUTH)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tcsi_GetCredential(hContext: TCS_CONTEXT_HANDLE,
                              ulCredentialType: UINT32,
                              ulCredentialAccessMode: UINT32,
                              pulCredentialSize: *mut UINT32,
                              prgbCredentialData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tddli_Open() -> TSS_RESULT;
}
extern "C" {
    pub fn Tddli_Close() -> TSS_RESULT;
}
extern "C" {
    pub fn Tddli_Cancel() -> TSS_RESULT;
}
extern "C" {
    pub fn Tddli_GetCapability(CapArea: UINT32, SubCap: UINT32,
                               pCapBuf: *mut BYTE, puntCapBufLen: *mut UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tddli_SetCapability(CapArea: UINT32, SubCap: UINT32,
                               pCapBuf: *mut BYTE, puntCapBufLen: UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tddli_GetStatus(ReqStatusType: UINT32, puntStatus: *mut UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tddli_TransmitData(pTransmitBuf: *mut BYTE, TransmitBufLen: UINT32,
                              pReceiveBuf: *mut BYTE,
                              puntReceiveBufLen: *mut UINT32) -> TSS_RESULT;
}
extern "C" {
    pub fn Tddli_SetPowerManagement(SendSaveStateCommand: TSS_BOOL,
                                    QuerySetNewTPMPowerState: *mut UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tddli_PowerManagementControl(SendPowerManager: TSS_BOOL,
                                        DriverManagesPowerStates: *mut UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_EncodeDER_TssBlob(rawBlobSize: UINT32, rawBlob: *mut BYTE,
                                  blobType: UINT32, derBlobSize: *mut UINT32,
                                  derBlob: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_DecodeBER_TssBlob(berBlobSize: UINT32, berBlob: *mut BYTE,
                                  blobType: *mut UINT32,
                                  rawBlobSize: *mut UINT32,
                                  rawBlob: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_SetAttribUint32(hObject: TSS_HOBJECT, attribFlag: TSS_FLAG,
                                subFlag: TSS_FLAG, ulAttrib: UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_GetAttribUint32(hObject: TSS_HOBJECT, attribFlag: TSS_FLAG,
                                subFlag: TSS_FLAG, pulAttrib: *mut UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_SetAttribData(hObject: TSS_HOBJECT, attribFlag: TSS_FLAG,
                              subFlag: TSS_FLAG, ulAttribDataSize: UINT32,
                              rgbAttribData: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_GetAttribData(hObject: TSS_HOBJECT, attribFlag: TSS_FLAG,
                              subFlag: TSS_FLAG,
                              pulAttribDataSize: *mut UINT32,
                              prgbAttribData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_ChangeAuth(hObjectToChange: TSS_HOBJECT,
                           hParentObject: TSS_HOBJECT,
                           hNewPolicy: TSS_HPOLICY) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_ChangeAuthAsym(hObjectToChange: TSS_HOBJECT,
                               hParentObject: TSS_HOBJECT,
                               hIdentKey: TSS_HKEY, hNewPolicy: TSS_HPOLICY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_GetPolicyObject(hObject: TSS_HOBJECT, policyType: TSS_FLAG,
                                phPolicy: *mut TSS_HPOLICY) -> TSS_RESULT;
}
#[link(name = "tspi")]
extern "C" {
    pub fn Tspi_Context_Create(phContext: *mut TSS_HCONTEXT) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_Close(hContext: TSS_HCONTEXT) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_Connect(hContext: TSS_HCONTEXT,
                                wszDestination: *mut TSS_UNICODE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_FreeMemory(hContext: TSS_HCONTEXT,
                                   rgbMemory: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_GetDefaultPolicy(hContext: TSS_HCONTEXT,
                                         phPolicy: *mut TSS_HPOLICY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_CreateObject(hContext: TSS_HCONTEXT,
                                     objectType: TSS_FLAG,
                                     initFlags: TSS_FLAG,
                                     phObject: *mut TSS_HOBJECT)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_CloseObject(hContext: TSS_HCONTEXT,
                                    hObject: TSS_HOBJECT) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_GetCapability(hContext: TSS_HCONTEXT,
                                      capArea: TSS_FLAG,
                                      ulSubCapLength: UINT32,
                                      rgbSubCap: *mut BYTE,
                                      pulRespDataLength: *mut UINT32,
                                      prgbRespData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_GetTpmObject(hContext: TSS_HCONTEXT,
                                     phTPM: *mut TSS_HTPM) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_SetTransEncryptionKey(hContext: TSS_HCONTEXT,
                                              hKey: TSS_HKEY) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_CloseSignTransport(hContext: TSS_HCONTEXT,
                                           hSigningKey: TSS_HKEY,
                                           pValidationData:
                                               *mut TSS_VALIDATION)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_LoadKeyByBlob(hContext: TSS_HCONTEXT,
                                      hUnwrappingKey: TSS_HKEY,
                                      ulBlobLength: UINT32,
                                      rgbBlobData: *mut BYTE,
                                      phKey: *mut TSS_HKEY) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_LoadKeyByUUID(hContext: TSS_HCONTEXT,
                                      persistentStorageType: TSS_FLAG,
                                      uuidData: TSS_UUID,
                                      phKey: *mut TSS_HKEY) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_RegisterKey(hContext: TSS_HCONTEXT, hKey: TSS_HKEY,
                                    persistentStorageType: TSS_FLAG,
                                    uuidKey: TSS_UUID,
                                    persistentStorageTypeParent: TSS_FLAG,
                                    uuidParentKey: TSS_UUID) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_UnregisterKey(hContext: TSS_HCONTEXT,
                                      persistentStorageType: TSS_FLAG,
                                      uuidKey: TSS_UUID, phkey: *mut TSS_HKEY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_GetKeyByUUID(hContext: TSS_HCONTEXT,
                                     persistentStorageType: TSS_FLAG,
                                     uuidData: TSS_UUID, phKey: *mut TSS_HKEY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_GetKeyByPublicInfo(hContext: TSS_HCONTEXT,
                                           persistentStorageType: TSS_FLAG,
                                           algID: TSS_ALGORITHM_ID,
                                           ulPublicInfoLength: UINT32,
                                           rgbPublicInfo: *mut BYTE,
                                           phKey: *mut TSS_HKEY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_GetRegisteredKeysByUUID(hContext: TSS_HCONTEXT,
                                                persistentStorageType:
                                                    TSS_FLAG,
                                                pUuidData: *mut TSS_UUID,
                                                pulKeyHierarchySize:
                                                    *mut UINT32,
                                                ppKeyHierarchy:
                                                    *mut *mut TSS_KM_KEYINFO)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Context_GetRegisteredKeysByUUID2(hContext: TSS_HCONTEXT,
                                                 persistentStorageType:
                                                     TSS_FLAG,
                                                 pUuidData: *mut TSS_UUID,
                                                 pulKeyHierarchySize:
                                                     *mut UINT32,
                                                 ppKeyHierarchy:
                                                     *mut *mut TSS_KM_KEYINFO2)
     -> TSS_RESULT;
}
// EDIT: changed mut to const since this data never changes
extern "C" {
    pub fn Tspi_Policy_SetSecret(hPolicy: TSS_HPOLICY, secretMode: TSS_FLAG,
                                 ulSecretLength: UINT32, rgbSecret: *const BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Policy_FlushSecret(hPolicy: TSS_HPOLICY) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Policy_AssignToObject(hPolicy: TSS_HPOLICY,
                                      hObject: TSS_HOBJECT) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_KeyControlOwner(hTPM: TSS_HTPM, hKey: TSS_HKEY,
                                    attribName: UINT32, attribValue: TSS_BOOL,
                                    pUuidData: *mut TSS_UUID) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_CreateEndorsementKey(hTPM: TSS_HTPM, hKey: TSS_HKEY,
                                         pValidationData: *mut TSS_VALIDATION)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_CreateRevocableEndorsementKey(hTPM: TSS_HTPM,
                                                  hKey: TSS_HKEY,
                                                  pValidationData:
                                                      *mut TSS_VALIDATION,
                                                  pulEkResetDataLength:
                                                      *mut UINT32,
                                                  rgbEkResetData:
                                                      *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_RevokeEndorsementKey(hTPM: TSS_HTPM,
                                         ulEkResetDataLength: UINT32,
                                         rgbEkResetData: *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetPubEndorsementKey(hTPM: TSS_HTPM,
                                         fOwnerAuthorized: TSS_BOOL,
                                         pValidationData: *mut TSS_VALIDATION,
                                         phEndorsementPubKey: *mut TSS_HKEY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_OwnerGetSRKPubKey(hTPM: TSS_HTPM,
                                      pulPubKeyLength: *mut UINT32,
                                      prgbPubKey: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_TakeOwnership(hTPM: TSS_HTPM, hKeySRK: TSS_HKEY,
                                  hEndorsementPubKey: TSS_HKEY) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_ClearOwner(hTPM: TSS_HTPM, fForcedClear: TSS_BOOL)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_CollateIdentityRequest(hTPM: TSS_HTPM, hKeySRK: TSS_HKEY,
                                           hCAPubKey: TSS_HKEY,
                                           ulIdentityLabelLength: UINT32,
                                           rgbIdentityLabelData: *mut BYTE,
                                           hIdentityKey: TSS_HKEY,
                                           algID: TSS_ALGORITHM_ID,
                                           pulTCPAIdentityReqLength:
                                               *mut UINT32,
                                           prgbTCPAIdentityReq:
                                               *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_ActivateIdentity(hTPM: TSS_HTPM, hIdentKey: TSS_HKEY,
                                     ulAsymCAContentsBlobLength: UINT32,
                                     rgbAsymCAContentsBlob: *mut BYTE,
                                     ulSymCAAttestationBlobLength: UINT32,
                                     rgbSymCAAttestationBlob: *mut BYTE,
                                     pulCredentialLength: *mut UINT32,
                                     prgbCredential: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_CreateMaintenanceArchive(hTPM: TSS_HTPM,
                                             fGenerateRndNumber: TSS_BOOL,
                                             pulRndNumberLength: *mut UINT32,
                                             prgbRndNumber: *mut *mut BYTE,
                                             pulArchiveDataLength:
                                                 *mut UINT32,
                                             prgbArchiveData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_KillMaintenanceFeature(hTPM: TSS_HTPM) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_LoadMaintenancePubKey(hTPM: TSS_HTPM,
                                          hMaintenanceKey: TSS_HKEY,
                                          pValidationData:
                                              *mut TSS_VALIDATION)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_CheckMaintenancePubKey(hTPM: TSS_HTPM,
                                           hMaintenanceKey: TSS_HKEY,
                                           pValidationData:
                                               *mut TSS_VALIDATION)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_SetOperatorAuth(hTPM: TSS_HTPM,
                                    hOperatorPolicy: TSS_HPOLICY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_SetStatus(hTPM: TSS_HTPM, statusFlag: TSS_FLAG,
                              fTpmState: TSS_BOOL) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetStatus(hTPM: TSS_HTPM, statusFlag: TSS_FLAG,
                              pfTpmState: *mut TSS_BOOL) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetCapability(hTPM: TSS_HTPM, capArea: TSS_FLAG,
                                  ulSubCapLength: UINT32,
                                  rgbSubCap: *mut BYTE,
                                  pulRespDataLength: *mut UINT32,
                                  prgbRespData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetCapabilitySigned(hTPM: TSS_HTPM, hKey: TSS_HKEY,
                                        capArea: TSS_FLAG,
                                        ulSubCapLength: UINT32,
                                        rgbSubCap: *mut BYTE,
                                        pValidationData: *mut TSS_VALIDATION,
                                        pulRespDataLength: *mut UINT32,
                                        prgbRespData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_SelfTestFull(hTPM: TSS_HTPM) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_CertifySelfTest(hTPM: TSS_HTPM, hKey: TSS_HKEY,
                                    pValidationData: *mut TSS_VALIDATION)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetTestResult(hTPM: TSS_HTPM,
                                  pulTestResultLength: *mut UINT32,
                                  prgbTestResult: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetRandom(hTPM: TSS_HTPM, ulRandomDataLength: UINT32,
                              prgbRandomData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_StirRandom(hTPM: TSS_HTPM, ulEntropyDataLength: UINT32,
                               rgbEntropyData: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetEvent(hTPM: TSS_HTPM, ulPcrIndex: UINT32,
                             ulEventNumber: UINT32,
                             pPcrEvent: *mut TSS_PCR_EVENT) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetEvents(hTPM: TSS_HTPM, ulPcrIndex: UINT32,
                              ulStartNumber: UINT32,
                              pulEventNumber: *mut UINT32,
                              prgPcrEvents: *mut *mut TSS_PCR_EVENT)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetEventLog(hTPM: TSS_HTPM, pulEventNumber: *mut UINT32,
                                prgPcrEvents: *mut *mut TSS_PCR_EVENT)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Quote(hTPM: TSS_HTPM, hIdentKey: TSS_HKEY,
                          hPcrComposite: TSS_HPCRS,
                          pValidationData: *mut TSS_VALIDATION) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Quote2(hTPM: TSS_HTPM, hIdentKey: TSS_HKEY,
                           fAddVersion: TSS_BOOL, hPcrComposite: TSS_HPCRS,
                           pValidationData: *mut TSS_VALIDATION,
                           versionInfoSize: *mut UINT32,
                           versionInfo: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_PcrExtend(hTPM: TSS_HTPM, ulPcrIndex: UINT32,
                              ulPcrDataLength: UINT32, pbPcrData: *mut BYTE,
                              pPcrEvent: *mut TSS_PCR_EVENT,
                              pulPcrValueLength: *mut UINT32,
                              prgbPcrValue: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_PcrRead(hTPM: TSS_HTPM, ulPcrIndex: UINT32,
                            pulPcrValueLength: *mut UINT32,
                            prgbPcrValue: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_PcrReset(hTPM: TSS_HTPM, hPcrComposite: TSS_HPCRS)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_AuthorizeMigrationTicket(hTPM: TSS_HTPM,
                                             hMigrationKey: TSS_HKEY,
                                             migrationScheme:
                                                 TSS_MIGRATE_SCHEME,
                                             pulMigTicketLength: *mut UINT32,
                                             prgbMigTicket: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_CMKSetRestrictions(hTPM: TSS_HTPM,
                                       CmkDelegate: TSS_CMK_DELEGATE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_CMKApproveMA(hTPM: TSS_HTPM, hMaAuthData: TSS_HMIGDATA)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_CMKCreateTicket(hTPM: TSS_HTPM, hVerifyKey: TSS_HKEY,
                                    hSigData: TSS_HMIGDATA) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_ReadCounter(hTPM: TSS_HTPM, counterValue: *mut UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_ReadCurrentTicks(hTPM: TSS_HTPM,
                                     tickCount: *mut TPM_CURRENT_TICKS)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_DirWrite(hTPM: TSS_HTPM, ulDirIndex: UINT32,
                             ulDirDataLength: UINT32, rgbDirData: *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_DirRead(hTPM: TSS_HTPM, ulDirIndex: UINT32,
                            pulDirDataLength: *mut UINT32,
                            prgbDirData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Delegate_AddFamily(hTPM: TSS_HTPM, bLabel: BYTE,
                                       phFamily: *mut TSS_HDELFAMILY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Delegate_GetFamily(hTPM: TSS_HTPM, ulFamilyID: UINT32,
                                       phFamily: *mut TSS_HDELFAMILY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Delegate_InvalidateFamily(hTPM: TSS_HTPM,
                                              hFamily: TSS_HDELFAMILY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Delegate_CreateDelegation(hObject: TSS_HOBJECT,
                                              bLabel: BYTE, ulFlags: UINT32,
                                              hPcr: TSS_HPCRS,
                                              hFamily: TSS_HDELFAMILY,
                                              hDelegation: TSS_HPOLICY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Delegate_CacheOwnerDelegation(hTPM: TSS_HTPM,
                                                  hDelegation: TSS_HPOLICY,
                                                  ulIndex: UINT32,
                                                  ulFlags: UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Delegate_UpdateVerificationCount(hTPM: TSS_HTPM,
                                                     hDelegation: TSS_HPOLICY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Delegate_VerifyDelegation(hDelegation: TSS_HPOLICY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_Delegate_ReadTables(hContext: TSS_HCONTEXT,
                                        pulFamilyTableSize: *mut UINT32,
                                        ppFamilyTable:
                                            *mut *mut TSS_FAMILY_TABLE_ENTRY,
                                        pulDelegateTableSize: *mut UINT32,
                                        ppDelegateTable:
                                            *mut *mut TSS_DELEGATION_TABLE_ENTRY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_DAA_JoinInit(hTPM: TSS_HTPM,
                                 hIssuerKey: TSS_HDAA_ISSUER_KEY,
                                 daaCounter: UINT32,
                                 issuerAuthPKsLength: UINT32,
                                 issuerAuthPKs: *mut TSS_HKEY,
                                 issuerAuthPKSignaturesLength: UINT32,
                                 issuerAuthPKSignaturesLength2: UINT32,
                                 issuerAuthPKSignatures: *mut *mut BYTE,
                                 capitalUprimeLength: *mut UINT32,
                                 capitalUprime: *mut *mut BYTE,
                                 identityProof:
                                     *mut *mut TSS_DAA_IDENTITY_PROOF,
                                 joinSessionLength: *mut UINT32,
                                 joinSession: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_DAA_JoinCreateDaaPubKey(hTPM: TSS_HTPM,
                                            hDAACredential:
                                                TSS_HDAA_CREDENTIAL,
                                            authenticationChallengeLength:
                                                UINT32,
                                            authenticationChallenge:
                                                *mut BYTE,
                                            nonceIssuerLength: UINT32,
                                            nonceIssuer: *mut BYTE,
                                            attributesPlatformLength: UINT32,
                                            attributesPlatformLength2: UINT32,
                                            attributesPlatform:
                                                *mut *mut BYTE,
                                            joinSessionLength: UINT32,
                                            joinSession: *mut BYTE,
                                            credentialRequest:
                                                *mut *mut TSS_DAA_CREDENTIAL_REQUEST)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_DAA_JoinStoreCredential(hTPM: TSS_HTPM,
                                            hDAACredential:
                                                TSS_HDAA_CREDENTIAL,
                                            credIssuer:
                                                *mut TSS_DAA_CRED_ISSUER,
                                            joinSessionLength: UINT32,
                                            joinSession: *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_DAA_Sign(hTPM: TSS_HTPM,
                             hDAACredential: TSS_HDAA_CREDENTIAL,
                             hARAKey: TSS_HDAA_ARA_KEY,
                             revealAttributes: *mut TSS_DAA_SELECTED_ATTRIB,
                             verifierNonceLength: UINT32,
                             verifierNonce: *mut BYTE,
                             verifierBaseNameLength: UINT32,
                             verifierBaseName: *mut BYTE,
                             signData: TSS_HOBJECT,
                             daaSignature: *mut *mut TSS_DAA_SIGNATURE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_TPM_GetAuditDigest(hTPM: TSS_HTPM, hKey: TSS_HKEY,
                                   closeAudit: TSS_BOOL,
                                   pulAuditDigestSize: *mut UINT32,
                                   prgbAuditDigest: *mut *mut BYTE,
                                   pCounterValue: *mut TPM_COUNTER_VALUE,
                                   pValidationData: *mut TSS_VALIDATION,
                                   ordSize: *mut UINT32,
                                   ordList: *mut *mut UINT32) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_PcrComposite_SelectPcrIndex(hPcrComposite: TSS_HPCRS,
                                            ulPcrIndex: UINT32) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_PcrComposite_SelectPcrIndexEx(hPcrComposite: TSS_HPCRS,
                                              ulPcrIndex: UINT32,
                                              direction: UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_PcrComposite_SetPcrValue(hPcrComposite: TSS_HPCRS,
                                         ulPcrIndex: UINT32,
                                         ulPcrValueLength: UINT32,
                                         rgbPcrValue: *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_PcrComposite_GetPcrValue(hPcrComposite: TSS_HPCRS,
                                         ulPcrIndex: UINT32,
                                         pulPcrValueLength: *mut UINT32,
                                         prgbPcrValue: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_PcrComposite_SetPcrLocality(hPcrComposite: TSS_HPCRS,
                                            LocalityValue: UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_PcrComposite_GetPcrLocality(hPcrComposite: TSS_HPCRS,
                                            pLocalityValue: *mut UINT32)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_PcrComposite_GetCompositeHash(hPcrComposite: TSS_HPCRS,
                                              pLen: *mut UINT32,
                                              ppbHashData: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_LoadKey(hKey: TSS_HKEY, hUnwrappingKey: TSS_HKEY)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_UnloadKey(hKey: TSS_HKEY) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_GetPubKey(hKey: TSS_HKEY, pulPubKeyLength: *mut UINT32,
                              prgbPubKey: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_CertifyKey(hKey: TSS_HKEY, hCertifyingKey: TSS_HKEY,
                               pValidationData: *mut TSS_VALIDATION)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_CreateKey(hKey: TSS_HKEY, hWrappingKey: TSS_HKEY,
                              hPcrComposite: TSS_HPCRS) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_WrapKey(hKey: TSS_HKEY, hWrappingKey: TSS_HKEY,
                            hPcrComposite: TSS_HPCRS) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_CreateMigrationBlob(hKeyToMigrate: TSS_HKEY,
                                        hParentKey: TSS_HKEY,
                                        ulMigTicketLength: UINT32,
                                        rgbMigTicket: *mut BYTE,
                                        pulRandomLength: *mut UINT32,
                                        prgbRandom: *mut *mut BYTE,
                                        pulMigrationBlobLength: *mut UINT32,
                                        prgbMigrationBlob: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_ConvertMigrationBlob(hKeyToMigrate: TSS_HKEY,
                                         hParentKey: TSS_HKEY,
                                         ulRandomLength: UINT32,
                                         rgbRandom: *mut BYTE,
                                         ulMigrationBlobLength: UINT32,
                                         rgbMigrationBlob: *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_MigrateKey(hMaKey: TSS_HKEY, hPublicKey: TSS_HKEY,
                               hMigData: TSS_HKEY) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_CMKCreateBlob(hKeyToMigrate: TSS_HKEY,
                                  hParentKey: TSS_HKEY,
                                  hMigrationData: TSS_HMIGDATA,
                                  pulRandomLength: *mut UINT32,
                                  prgbRandom: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Key_CMKConvertMigration(hKeyToMigrate: TSS_HKEY,
                                        hParentKey: TSS_HKEY,
                                        hMigrationData: TSS_HMIGDATA,
                                        ulRandomLength: UINT32,
                                        rgbRandom: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Hash_Sign(hHash: TSS_HHASH, hKey: TSS_HKEY,
                          pulSignatureLength: *mut UINT32,
                          prgbSignature: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Hash_VerifySignature(hHash: TSS_HHASH, hKey: TSS_HKEY,
                                     ulSignatureLength: UINT32,
                                     rgbSignature: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Hash_SetHashValue(hHash: TSS_HHASH, ulHashValueLength: UINT32,
                                  rgbHashValue: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Hash_GetHashValue(hHash: TSS_HHASH,
                                  pulHashValueLength: *mut UINT32,
                                  prgbHashValue: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Hash_UpdateHashValue(hHash: TSS_HHASH, ulDataLength: UINT32,
                                     rgbData: *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Hash_TickStampBlob(hHash: TSS_HHASH, hIdentKey: TSS_HKEY,
                                   pValidationData: *mut TSS_VALIDATION)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Data_Bind(hEncData: TSS_HENCDATA, hEncKey: TSS_HKEY,
                          ulDataLength: UINT32, rgbDataToBind: *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Data_Unbind(hEncData: TSS_HENCDATA, hKey: TSS_HKEY,
                            pulUnboundDataLength: *mut UINT32,
                            prgbUnboundData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Data_Seal(hEncData: TSS_HENCDATA, hEncKey: TSS_HKEY,
                          ulDataLength: UINT32, rgbDataToSeal: *mut BYTE,
                          hPcrComposite: TSS_HPCRS) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_Data_Unseal(hEncData: TSS_HENCDATA, hKey: TSS_HKEY,
                            pulUnsealedDataLength: *mut UINT32,
                            prgbUnsealedData: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_NV_DefineSpace(hNVStore: TSS_HNVSTORE,
                               hReadPcrComposite: TSS_HPCRS,
                               hWritePcrComposite: TSS_HPCRS) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_NV_ReleaseSpace(hNVStore: TSS_HNVSTORE) -> TSS_RESULT;
}
// EDIT: changed mut to const since this data never changes
extern "C" {
    pub fn Tspi_NV_WriteValue(hNVStore: TSS_HNVSTORE, offset: UINT32,
                              ulDataLength: UINT32, rgbDataToWrite: *const BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_NV_ReadValue(hNVStore: TSS_HNVSTORE, offset: UINT32,
                             ulDataLength: *mut UINT32,
                             rgbDataRead: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_DAA_IssuerKeyVerify(hDAACredential: TSS_HDAA_CREDENTIAL,
                                    hIssuerKey: TSS_HDAA_ISSUER_KEY,
                                    isCorrect: *mut TSS_BOOL) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_DAA_Issuer_GenerateKey(hIssuerKey: TSS_HDAA_ISSUER_KEY,
                                       issuerBaseNameLength: UINT32,
                                       issuerBaseName: *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_DAA_Issuer_InitCredential(hIssuerKey: TSS_HDAA_ISSUER_KEY,
                                          issuerAuthPK: TSS_HKEY,
                                          identityProof:
                                              *mut TSS_DAA_IDENTITY_PROOF,
                                          capitalUprimeLength: UINT32,
                                          capitalUprime: *mut BYTE,
                                          daaCounter: UINT32,
                                          nonceIssuerLength: *mut UINT32,
                                          nonceIssuer: *mut *mut BYTE,
                                          authenticationChallengeLength:
                                              *mut UINT32,
                                          authenticationChallenge:
                                              *mut *mut BYTE,
                                          joinSessionLength: *mut UINT32,
                                          joinSession: *mut *mut BYTE)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_DAA_Issuer_IssueCredential(hIssuerKey: TSS_HDAA_ISSUER_KEY,
                                           credentialRequest:
                                               *mut TSS_DAA_CREDENTIAL_REQUEST,
                                           issuerJoinSessionLength: UINT32,
                                           issuerJoinSession: *mut BYTE,
                                           credIssuer:
                                               *mut *mut TSS_DAA_CRED_ISSUER)
     -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_DAA_Verifier_Init(hDAACredential: TSS_HDAA_CREDENTIAL,
                                  nonceVerifierLength: *mut UINT32,
                                  nonceVerifier: *mut *mut BYTE,
                                  baseNameLength: *mut UINT32,
                                  baseName: *mut *mut BYTE) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_DAA_VerifySignature(hDAACredential: TSS_HDAA_CREDENTIAL,
                                    hIssuerKey: TSS_HDAA_ISSUER_KEY,
                                    hARAKey: TSS_HDAA_ARA_KEY,
                                    hARACondition: TSS_HHASH,
                                    attributesLength: UINT32,
                                    attributesLength2: UINT32,
                                    attributes: *mut *mut BYTE,
                                    verifierNonceLength: UINT32,
                                    verifierNonce: *mut BYTE,
                                    verifierBaseNameLength: UINT32,
                                    verifierBaseName: *mut BYTE,
                                    signData: TSS_HOBJECT,
                                    daaSignature: *mut TSS_DAA_SIGNATURE,
                                    isCorrect: *mut TSS_BOOL) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_DAA_ARA_GenerateKey(hIssuerKey: TSS_HDAA_ISSUER_KEY,
                                    hARAKey: TSS_HDAA_ARA_KEY) -> TSS_RESULT;
}
extern "C" {
    pub fn Tspi_DAA_ARA_RevokeAnonymity(hARAKey: TSS_HDAA_ARA_KEY,
                                        hARACondition: TSS_HHASH,
                                        hIssuerKey: TSS_HDAA_ISSUER_KEY,
                                        encryptedPseudonym:
                                            *mut TSS_DAA_PSEUDONYM_ENCRYPTED,
                                        pseudonym:
                                            *mut *mut TSS_DAA_PSEUDONYM_PLAIN)
     -> TSS_RESULT;
}
pub type Tspicb_CallbackHMACAuth =
    ::std::option::Option<unsafe extern "C" fn(lpAppData: PVOID,
                                               hAuthorizedObject: TSS_HOBJECT,
                                               ReturnOrVerify: TSS_BOOL,
                                               ulPendingFunction: UINT32,
                                               ContinueUse: TSS_BOOL,
                                               ulSizeNonces: UINT32,
                                               rgbNonceEven: *mut BYTE,
                                               rgbNonceOdd: *mut BYTE,
                                               rgbNonceEvenOSAP: *mut BYTE,
                                               rgbNonceOddOSAP: *mut BYTE,
                                               ulSizeDigestHmac: UINT32,
                                               rgbParamDigest: *mut BYTE,
                                               rgbHmacData: *mut BYTE)
                              -> TSS_RESULT>;
pub type Tspicb_CallbackXorEnc =
    ::std::option::Option<unsafe extern "C" fn(lpAppData: PVOID,
                                               hOSAPObject: TSS_HOBJECT,
                                               hObject: TSS_HOBJECT,
                                               PurposeSecret: TSS_FLAG,
                                               ulSizeNonces: UINT32,
                                               rgbNonceEven: *mut BYTE,
                                               rgbNonceOdd: *mut BYTE,
                                               rgbNonceEvenOSAP: *mut BYTE,
                                               rgbNonceOddOSAP: *mut BYTE,
                                               ulSizeEncAuth: UINT32,
                                               rgbEncAuthUsage: *mut BYTE,
                                               rgbEncAuthMigration: *mut BYTE)
                              -> TSS_RESULT>;
pub type Tspicb_CallbackTakeOwnership =
    ::std::option::Option<unsafe extern "C" fn(lpAppData: PVOID,
                                               hObject: TSS_HOBJECT,
                                               hObjectPubKey: TSS_HKEY,
                                               ulSizeEncAuth: UINT32,
                                               rgbEncAuth: *mut BYTE)
                              -> TSS_RESULT>;
pub type Tspicb_CallbackSealxMask =
    ::std::option::Option<unsafe extern "C" fn(lpAppData: PVOID,
                                               hKey: TSS_HKEY,
                                               hEncData: TSS_HENCDATA,
                                               algID: TSS_ALGORITHM_ID,
                                               ulSizeNonces: UINT32,
                                               rgbNonceEven: *mut BYTE,
                                               rgbNonceOdd: *mut BYTE,
                                               rgbNonceEvenOSAP: *mut BYTE,
                                               rgbNonceOddOSAP: *mut BYTE,
                                               ulDataLength: UINT32,
                                               rgbDataToMask: *mut BYTE,
                                               rgbMaskedData: *mut BYTE)
                              -> TSS_RESULT>;
pub type Tspicb_CallbackChangeAuthAsym =
    ::std::option::Option<unsafe extern "C" fn(lpAppData: PVOID,
                                               hObject: TSS_HOBJECT,
                                               hObjectPubKey: TSS_HKEY,
                                               ulSizeEncAuth: UINT32,
                                               ulSizeAuthLink: UINT32,
                                               rgbEncAuth: *mut BYTE,
                                               rgbAuthLink: *mut BYTE)
                              -> TSS_RESULT>;
pub type Tspicb_CollateIdentity =
    ::std::option::Option<unsafe extern "C" fn(lpAppData: PVOID,
                                               ulTCPAPlainIdentityProofLength:
                                                   UINT32,
                                               rgbTCPAPlainIdentityProof:
                                                   *mut BYTE,
                                               algID: TSS_ALGORITHM_ID,
                                               ulSessionKeyLength: UINT32,
                                               rgbSessionKey: *mut BYTE,
                                               pulTCPAIdentityProofLength:
                                                   *mut UINT32,
                                               rgbTCPAIdentityProof:
                                                   *mut BYTE) -> TSS_RESULT>;
pub type Tspicb_ActivateIdentity =
    ::std::option::Option<unsafe extern "C" fn(lpAppData: PVOID,
                                               ulSessionKeyLength: UINT32,
                                               rgbSessionKey: *mut BYTE,
                                               ulSymCAAttestationBlobLength:
                                                   UINT32,
                                               rgbSymCAAttestationBlob:
                                                   *mut BYTE,
                                               pulCredentialLength:
                                                   *mut UINT32,
                                               rgbCredential: *mut BYTE)
                              -> TSS_RESULT>;
pub type Tspicb_DAA_Sign =
    ::std::option::Option<unsafe extern "C" fn(lpAppData: PVOID,
                                               daaPublicKey:
                                                   TSS_HDAA_ISSUER_KEY,
                                               gammasLength: UINT32,
                                               gammas: *mut *mut BYTE,
                                               attributesLength: UINT32,
                                               attributes: *mut *mut BYTE,
                                               randomAttributesLength: UINT32,
                                               randomAttributes:
                                                   *mut *mut BYTE,
                                               attributeCommitmentsLength:
                                                   UINT32,
                                               attributeCommitments:
                                                   *mut TSS_DAA_ATTRIB_COMMIT,
                                               attributeCommitmentsProof:
                                                   *mut TSS_DAA_ATTRIB_COMMIT,
                                               pseudonym:
                                                   *mut TSS_DAA_PSEUDONYM_PLAIN,
                                               pseudonymTilde:
                                                   *mut TSS_DAA_PSEUDONYM_PLAIN,
                                               pseudonymEncrypted:
                                                   *mut TSS_DAA_PSEUDONYM_ENCRYPTED,
                                               pseudonymEncProof:
                                                   *mut TSS_DAA_PSEUDONYM_ENCRYPTED,
                                               additionalProof:
                                                   *mut *mut TSS_DAA_SIGN_CALLBACK)
                              -> TSS_RESULT>;
pub type Tspicb_DAA_VerifySignature =
    ::std::option::Option<unsafe extern "C" fn(lpAppData: PVOID,
                                               challengeLength: UINT32,
                                               challenge: *mut BYTE,
                                               additionalProof:
                                                   *mut TSS_DAA_SIGN_CALLBACK,
                                               daaPublicKey:
                                                   TSS_HDAA_ISSUER_KEY,
                                               gammasLength: UINT32,
                                               gammas: *mut *mut BYTE,
                                               sAttributesLength: UINT32,
                                               sAttributes: *mut *mut BYTE,
                                               attributeCommitmentsLength:
                                                   UINT32,
                                               attributeCommitments:
                                                   *mut TSS_DAA_ATTRIB_COMMIT,
                                               attributeCommitmentsProof:
                                                   *mut TSS_DAA_ATTRIB_COMMIT,
                                               zetaLength: UINT32,
                                               zeta: *mut BYTE,
                                               sFLength: UINT32,
                                               sF: *mut BYTE,
                                               pseudonym:
                                                   *mut TSS_DAA_PSEUDONYM,
                                               pseudonymProof:
                                                   *mut TSS_DAA_PSEUDONYM,
                                               isCorrect: *mut TSS_BOOL)
                              -> TSS_RESULT>;
